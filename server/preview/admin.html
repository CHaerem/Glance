<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Inline mock API for preview mode (must load synchronously) -->
    <script>
        // Auto-detect preview mode
        (function() {
            const isGitHubPages = window.location.hostname.includes('github.io');
            const isLocalFile = window.location.protocol === 'file:';

            if (!isGitHubPages && !isLocalFile) {
                console.log('[Preview] Production mode - using real backend');
                return;
            }

            console.log('[Preview] Mock mode activated');

            // Load mock API immediately (synchronously)
            /**
 * Mock API Server for GitHub Pages Preview
 *
 * Enhanced version with visually rich placeholder generation
 * for proper UX/design testing
 */

class MockAPI {
    constructor() {
        this.storage = {
            settings: {
                defaultSleepDuration: 3600000000,
                devMode: false,
                devServerHost: '',
                defaultOrientation: 'portrait',
                nightSleepEnabled: false,
                nightSleepStartHour: 23,
                nightSleepEndHour: 5
            },
            currentImage: {
                imageId: 'demo-001',
                originalImage: null,
                originalImageMime: 'image/png',
                originalPrompt: 'A serene landscape with mountains and a lake at sunset',
                timestamp: Date.now() - 3600000
            },
            images: new Map(),
            history: [],
            devices: {
                'esp32-001': {
                    deviceId: 'esp32-001',
                    state: 'sleeping',
                    batteryVoltage: 4.1,
                    batteryPercent: 85,
                    isCharging: false,
                    lastChargeTimestamp: Date.now() - 7200000,
                    signalStrength: -45,
                    lastSeen: Date.now() - 1800000,
                    sleepDuration: 3600000000,
                    status: 'sleeping'
                }
            },
            logs: [
                '[2025-10-30 10:15:32] Server started',
                '[2025-10-30 10:15:33] Mock API initialized',
                '[2025-10-30 10:16:45] ESP32 connected',
                '[2025-10-30 10:17:12] Image generated: demo-001'
            ],
            deviceLogs: [
                '[2025-10-30 10:16:45] ESP32 woke up',
                '[2025-10-30 10:16:46] Connected to WiFi',
                '[2025-10-30 10:16:47] Battery: 4.1V (85%)',
                '[2025-10-30 10:17:12] Display refresh complete',
                '[2025-10-30 10:17:13] Entering deep sleep for 60 minutes'
            ],
            collections: this.generateMockCollections(),
            myCollection: []
        };

        this.generateDemoImage();
        this.initializeMyCollection();
    }

    /**
     * Generate visually rich placeholder based on prompt
     */
    generateArtisticImage(prompt, width = 400, height = 533) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        // Extract style hints from prompt
        const lowerPrompt = prompt.toLowerCase();
        let style = 'abstract';

        if (lowerPrompt.includes('landscape') || lowerPrompt.includes('mountain') || lowerPrompt.includes('lake')) {
            style = 'landscape';
        } else if (lowerPrompt.includes('portrait') || lowerPrompt.includes('face') || lowerPrompt.includes('person')) {
            style = 'portrait';
        } else if (lowerPrompt.includes('geometric') || lowerPrompt.includes('pattern')) {
            style = 'geometric';
        } else if (lowerPrompt.includes('minimal')) {
            style = 'minimal';
        }

        // Generate based on style
        switch(style) {
            case 'landscape':
                this.drawLandscape(ctx, width, height, prompt);
                break;
            case 'portrait':
                this.drawPortrait(ctx, width, height, prompt);
                break;
            case 'geometric':
                this.drawGeometric(ctx, width, height, prompt);
                break;
            case 'minimal':
                this.drawMinimal(ctx, width, height, prompt);
                break;
            default:
                this.drawAbstract(ctx, width, height, prompt);
        }

        // Add subtle prompt text at bottom
        this.addPromptOverlay(ctx, width, height, prompt);

        return canvas.toDataURL('image/png').split(',')[1];
    }

    drawLandscape(ctx, width, height, prompt) {
        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.6);
        skyGradient.addColorStop(0, '#87CEEB');
        skyGradient.addColorStop(0.5, '#B0E0E6');
        skyGradient.addColorStop(1, '#FFE4B5');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height * 0.6);

        // Mountains in layers
        const mountainLayers = [
            { y: height * 0.4, color: '#4A5568', points: 5 },
            { y: height * 0.45, color: '#718096', points: 6 },
            { y: height * 0.5, color: '#A0AEC0', points: 7 }
        ];

        mountainLayers.forEach(layer => {
            ctx.fillStyle = layer.color;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.6);

            for (let i = 0; i <= layer.points; i++) {
                const x = (width / layer.points) * i;
                const peakHeight = layer.y + (Math.sin(i * 1.5) * height * 0.1);
                ctx.lineTo(x, peakHeight);
            }

            ctx.lineTo(width, height * 0.6);
            ctx.closePath();
            ctx.fill();
        });

        // Foreground - grass/lake
        const groundGradient = ctx.createLinearGradient(0, height * 0.6, 0, height);
        if (prompt.toLowerCase().includes('lake')) {
            groundGradient.addColorStop(0, '#4682B4');
            groundGradient.addColorStop(1, '#1E3A5F');
        } else {
            groundGradient.addColorStop(0, '#90EE90');
            groundGradient.addColorStop(1, '#228B22');
        }
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, height * 0.6, width, height * 0.4);

        // Sun/Moon
        ctx.fillStyle = prompt.toLowerCase().includes('sunset') ? '#FF6347' : '#FFD700';
        ctx.beginPath();
        ctx.arc(width * 0.8, height * 0.2, 30, 0, Math.PI * 2);
        ctx.fill();

        // Add some trees
        for (let i = 0; i < 5; i++) {
            const treeX = (width / 6) * (i + 1) + (Math.random() * 20 - 10);
            const treeY = height * 0.6 + (Math.random() * height * 0.1);
            this.drawTree(ctx, treeX, treeY, 15 + Math.random() * 10);
        }
    }

    drawTree(ctx, x, y, size) {
        // Trunk
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - size * 0.1, y, size * 0.2, size);

        // Foliage
        ctx.fillStyle = '#228B22';
        ctx.beginPath();
        ctx.moveTo(x, y - size * 0.5);
        ctx.lineTo(x - size * 0.4, y + size * 0.2);
        ctx.lineTo(x + size * 0.4, y + size * 0.2);
        ctx.closePath();
        ctx.fill();
    }

    drawPortrait(ctx, width, height) {
        // Background
        const bgGradient = ctx.createRadialGradient(width/2, height/3, 0, width/2, height/3, width);
        bgGradient.addColorStop(0, '#FFF5E1');
        bgGradient.addColorStop(1, '#D2B48C');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);

        // Head
        const centerX = width / 2;
        const centerY = height * 0.4;
        const headRadius = width * 0.25;

        ctx.fillStyle = '#FFDAB9';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, headRadius * 0.8, headRadius, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = '#4A2C2A';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY - headRadius * 0.3, headRadius * 0.85, headRadius * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#2C3E50';
        ctx.beginPath();
        ctx.arc(centerX - headRadius * 0.3, centerY - headRadius * 0.1, headRadius * 0.08, 0, Math.PI * 2);
        ctx.arc(centerX + headRadius * 0.3, centerY - headRadius * 0.1, headRadius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Nose
        ctx.strokeStyle = '#B8956A';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX - headRadius * 0.05, centerY + headRadius * 0.15);
        ctx.stroke();

        // Mouth
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY + headRadius * 0.3, headRadius * 0.3, 0.2, Math.PI - 0.2);
        ctx.stroke();

        // Shoulders
        ctx.fillStyle = '#4682B4';
        ctx.beginPath();
        ctx.moveTo(centerX - headRadius * 1.2, height);
        ctx.lineTo(centerX - headRadius * 0.6, centerY + headRadius);
        ctx.lineTo(centerX + headRadius * 0.6, centerY + headRadius);
        ctx.lineTo(centerX + headRadius * 1.2, height);
        ctx.closePath();
        ctx.fill();
    }

    drawGeometric(ctx, width, height) {
        // Clean background
        ctx.fillStyle = '#F5F5F5';
        ctx.fillRect(0, 0, width, height);

        // Generate geometric pattern
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];
        const shapes = Math.floor(Math.random() * 10) + 15;

        for (let i = 0; i < shapes; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 80 + 40;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const shape = Math.floor(Math.random() * 3);

            ctx.fillStyle = color + '80'; // Add transparency
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            switch(shape) {
                case 0: // Circle
                    ctx.arc(x, y, size/2, 0, Math.PI * 2);
                    break;
                case 1: // Square
                    ctx.rect(x - size/2, y - size/2, size, size);
                    break;
                case 2: // Triangle
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.closePath();
                    break;
            }
            ctx.fill();
            ctx.stroke();
        }
    }

    drawMinimal(ctx, width, height) {
        // White background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, width, height);

        // Single focal element
        const centerX = width / 2;
        const centerY = height / 2;

        // Large circle
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.min(width, height) * 0.3, 0, Math.PI * 2);
        ctx.stroke();

        // Smaller circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.min(width, height) * 0.15, 0, Math.PI * 2);
        ctx.stroke();

        // Line through
        ctx.beginPath();
        ctx.moveTo(centerX - width * 0.3, centerY);
        ctx.lineTo(centerX + width * 0.3, centerY);
        ctx.stroke();
    }

    drawAbstract(ctx, width, height) {
        // Colorful gradient background
        const hue1 = Math.random() * 360;
        const hue2 = (hue1 + 120) % 360;
        const hue3 = (hue1 + 240) % 360;

        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, `hsl(${hue1}, 70%, 60%)`);
        gradient.addColorStop(0.5, `hsl(${hue2}, 70%, 60%)`);
        gradient.addColorStop(1, `hsl(${hue3}, 70%, 60%)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Organic shapes
        const shapes = Math.floor(Math.random() * 5) + 8;
        for (let i = 0; i < shapes; i++) {
            ctx.fillStyle = `hsla(${Math.random() * 360}, 60%, 70%, 0.4)`;
            ctx.beginPath();

            const centerX = Math.random() * width;
            const centerY = Math.random() * height;
            const radius = Math.random() * 100 + 50;

            // Blob shape
            for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
                const wobble = Math.random() * 20 + radius;
                const x = centerX + Math.cos(angle) * wobble;
                const y = centerY + Math.sin(angle) * wobble;
                if (angle === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
        }
    }

    addPromptOverlay(ctx, width, height, prompt) {
        // Semi-transparent overlay at bottom
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, height - 60, width, 60);

        // Prompt text
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Truncate prompt if too long
        let displayPrompt = prompt;
        if (prompt.length > 50) {
            displayPrompt = prompt.substring(0, 47) + '...';
        }

        ctx.fillText(displayPrompt, width / 2, height - 30);
    }

    generateDemoImage() {
        // Generate a rich history of varied images
        const demoPrompts = [
            'A serene landscape with mountains and a lake at sunset',
            'Minimalist geometric pattern with circles',
            'Abstract colorful art with organic shapes',
            'Portrait of a person in contemplation',
            'Japanese landscape with Mount Fuji',
            'Geometric pattern with triangles and squares',
            'Mountain landscape at dawn with morning mist',
            'Minimalist design with simple lines',
            'Abstract expressionist artwork',
            'Peaceful lake scene with reflections',
            'Portrait in renaissance style',
            'Colorful geometric composition'
        ];

        // Generate images in reverse chronological order
        const now = Date.now();
        const hoursAgo = [0.5, 2, 5, 12, 24, 48, 72, 96, 120, 168, 240, 336]; // Hours ago

        demoPrompts.forEach((prompt, index) => {
            const imageId = `demo-${String(index + 1).padStart(3, '0')}`;
            const timestamp = now - (hoursAgo[index] * 3600000);

            const base64 = this.generateArtisticImage(prompt, 400, 533);

            const imageData = {
                imageId,
                originalImage: base64,
                originalImageMime: 'image/png',
                originalPrompt: prompt,
                thumbnail: base64,
                timestamp
            };

            this.storage.images.set(imageId, imageData);
            this.storage.history.push({
                imageId,
                thumbnail: base64,
                timestamp
            });
        });

        // Most recent image becomes current
        const latest = this.storage.history[0];
        const latestImage = this.storage.images.get(latest.imageId);
        this.storage.currentImage = {
            imageId: latestImage.imageId,
            originalImage: latestImage.originalImage,
            originalImageMime: latestImage.originalImageMime,
            originalPrompt: latestImage.originalPrompt,
            timestamp: latestImage.timestamp
        };

        console.log(`[MockAPI] Generated ${demoPrompts.length} demo images for history`);
    }

    initializeMyCollection() {
        // Initialize collection with mix of generated and external artworks
        const now = Date.now();

        // Add some generated images to collection
        const generatedImages = Array.from(this.storage.images.values()).slice(0, 3);
        generatedImages.forEach((img, index) => {
            this.storage.myCollection.push({
                id: img.imageId,
                imageId: img.imageId,
                thumbnail: img.thumbnail,
                originalImage: img.originalImage,
                originalImageMime: img.originalImageMime,
                title: img.originalPrompt.substring(0, 50),
                originalPrompt: img.originalPrompt,
                artist: 'Generated',
                collectionType: 'generated',
                addedAt: now - (index * 3600000),
                timestamp: img.timestamp
            });
        });

        // Add some external artworks
        const externalArtworks = [
            {
                id: 'external-1',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Tsunami_by_hokusai_19th_century.jpg/400px-Tsunami_by_hokusai_19th_century.jpg',
                title: 'The Great Wave off Kanagawa',
                artist: 'Katsushika Hokusai',
                year: '1831',
                thumbnail: this.generatePlaceholderSVG('Hokusai', '#1a6c9c'),
                collectionType: 'external',
                addedAt: now - 4 * 3600000
            },
            {
                id: 'external-2',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/400px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg',
                title: 'The Starry Night',
                artist: 'Vincent van Gogh',
                year: '1889',
                thumbnail: this.generatePlaceholderSVG('Van Gogh', '#4a5f8c'),
                collectionType: 'external',
                addedAt: now - 8 * 3600000
            },
            {
                id: 'external-3',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Michelangelo_-_Creation_of_Adam_%28cropped%29.jpg/400px-Michelangelo_-_Creation_of_Adam_%28cropped%29.jpg',
                title: 'The Creation of Adam',
                artist: 'Michelangelo',
                year: '1512',
                thumbnail: this.generatePlaceholderSVG('Michelangelo', '#8b7355'),
                collectionType: 'external',
                addedAt: now - 12 * 3600000
            }
        ];

        this.storage.myCollection.push(...externalArtworks);
        console.log(`[MockAPI] Initialized collection with ${this.storage.myCollection.length} items`);
    }

    generatePlaceholderSVG(text, color) {
        const svg = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"><rect width="200" height="200" fill="${color}"/><text x="100" y="100" font-family="sans-serif" font-size="18" fill="white" text-anchor="middle" dominant-baseline="middle">${text}</text></svg>`;
        return `data:image/svg+xml;base64,${btoa(svg)}`;
    }

    generateMockCollections() {
        return [
            { id: 'renaissance-masters', name: 'Renaissance Masters', description: 'Great works from the Renaissance period' },
            { id: 'dutch-masters', name: 'Dutch Masters', description: 'Dutch Golden Age paintings' },
            { id: 'impressionists', name: 'Impressionists', description: 'French Impressionist masterpieces' },
            { id: 'post-impressionists', name: 'Post-Impressionists', description: 'Post-Impressionist works' },
            { id: 'japanese-masters', name: 'Japanese Masters', description: 'Traditional Japanese art' },
            { id: 'modern-icons', name: 'Modern Icons', description: 'Modern and contemporary art' }
        ];
    }

    generateMockArtworks(collectionId) {
        // Generate visually distinct artwork placeholders
        const artworks = [];
        const artworkData = {
            'renaissance-masters': [
                { title: 'Mona Lisa', artist: 'Leonardo da Vinci', style: 'portrait' },
                { title: 'The Birth of Venus', artist: 'Sandro Botticelli', style: 'portrait' },
                { title: 'The School of Athens', artist: 'Raphael', style: 'geometric' },
                { title: 'The Creation of Adam', artist: 'Michelangelo', style: 'portrait' },
                { title: 'Primavera', artist: 'Sandro Botticelli', style: 'landscape' },
                { title: 'The Last Supper', artist: 'Leonardo da Vinci', style: 'geometric' },
                { title: 'David', artist: 'Michelangelo', style: 'portrait' },
                { title: 'The Sistine Madonna', artist: 'Raphael', style: 'portrait' }
            ],
            'dutch-masters': [
                { title: 'Girl with a Pearl Earring', artist: 'Johannes Vermeer', style: 'portrait' },
                { title: 'The Night Watch', artist: 'Rembrandt', style: 'abstract' },
                { title: 'The Milkmaid', artist: 'Johannes Vermeer', style: 'portrait' },
                { title: 'The Anatomy Lesson', artist: 'Rembrandt', style: 'geometric' },
                { title: 'View of Delft', artist: 'Johannes Vermeer', style: 'landscape' },
                { title: 'The Jewish Bride', artist: 'Rembrandt', style: 'portrait' },
                { title: 'The Music Lesson', artist: 'Johannes Vermeer', style: 'portrait' },
                { title: 'The Storm on the Sea', artist: 'Rembrandt', style: 'landscape' }
            ],
            'impressionists': [
                { title: 'Water Lilies', artist: 'Claude Monet', style: 'landscape' },
                { title: 'Bal du moulin de la Galette', artist: 'Pierre-Auguste Renoir', style: 'abstract' },
                { title: 'Impression, Sunrise', artist: 'Claude Monet', style: 'landscape' },
                { title: 'The Luncheon', artist: 'Pierre-Auguste Renoir', style: 'abstract' },
                { title: 'Woman with a Parasol', artist: 'Claude Monet', style: 'portrait' },
                { title: 'Dance at Le Moulin', artist: 'Pierre-Auguste Renoir', style: 'abstract' },
                { title: 'Rouen Cathedral', artist: 'Claude Monet', style: 'landscape' },
                { title: 'The Theatre Box', artist: 'Pierre-Auguste Renoir', style: 'portrait' }
            ],
            'post-impressionists': [
                { title: 'The Starry Night', artist: 'Vincent van Gogh', style: 'landscape' },
                { title: 'The Card Players', artist: 'Paul C√©zanne', style: 'portrait' },
                { title: 'A Sunday Afternoon', artist: 'Georges Seurat', style: 'geometric' },
                { title: 'Caf√© Terrace at Night', artist: 'Vincent van Gogh', style: 'landscape' },
                { title: 'Mont Sainte-Victoire', artist: 'Paul C√©zanne', style: 'landscape' },
                { title: 'Irises', artist: 'Vincent van Gogh', style: 'landscape' },
                { title: 'The Bathers', artist: 'Paul C√©zanne', style: 'abstract' },
                { title: 'Sunflowers', artist: 'Vincent van Gogh', style: 'landscape' }
            ],
            'japanese-masters': [
                { title: 'The Great Wave', artist: 'Hokusai', style: 'landscape' },
                { title: 'Red Fuji', artist: 'Hokusai', style: 'landscape' },
                { title: 'Plum Blossoms', artist: 'Hiroshige', style: 'minimal' },
                { title: 'Sudden Shower', artist: 'Hiroshige', style: 'landscape' },
                { title: 'Evening Snow', artist: 'Hiroshige', style: 'landscape' },
                { title: 'Moonlight on Sumida', artist: 'Hokusai', style: 'landscape' },
                { title: 'Cherry Blossoms', artist: 'Hiroshige', style: 'minimal' },
                { title: 'Dragon in Clouds', artist: 'Hokusai', style: 'abstract' }
            ],
            'modern-icons': [
                { title: 'The Persistence of Memory', artist: 'Salvador Dal√≠', style: 'abstract' },
                { title: 'Campbell\'s Soup Cans', artist: 'Andy Warhol', style: 'minimal' },
                { title: 'The Scream', artist: 'Edvard Munch', style: 'portrait' },
                { title: 'Guernica', artist: 'Pablo Picasso', style: 'abstract' },
                { title: 'Marilyn Diptych', artist: 'Andy Warhol', style: 'portrait' },
                { title: 'Les Demoiselles', artist: 'Pablo Picasso', style: 'geometric' },
                { title: 'The Weeping Woman', artist: 'Pablo Picasso', style: 'portrait' },
                { title: 'Banana', artist: 'Andy Warhol', style: 'minimal' }
            ]
        };

        const collectionArt = artworkData[collectionId] || [];

        collectionArt.forEach((art, index) => {
            const prompt = `${art.title} by ${art.artist}, ${art.style} style`;
            const thumbnail = this.generateArtisticImage(prompt, 200, 200);
            const fullImage = this.generateArtisticImage(prompt, 800, 800);

            artworks.push({
                id: `${collectionId}-${index}`,
                title: art.title,
                artist: art.artist,
                thumbnail: `data:image/png;base64,${thumbnail}`,
                imageUrl: `data:image/png;base64,${fullImage}`
            });
        });

        return artworks;
    }

    /**
     * Read file as base64 data URL
     */
    async readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                // Extract base64 part (remove data:image/...;base64, prefix)
                const result = reader.result;
                const base64 = result.split(',')[1];
                resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    generateRandomPrompt(basePrompt = '') {
        const subjects = ['landscape', 'portrait', 'abstract art', 'still life', 'cityscape', 'seascape'];
        const styles = ['impressionist', 'minimalist', 'art nouveau', 'art deco', 'cubist', 'surrealist'];
        const moods = ['serene', 'dramatic', 'whimsical', 'melancholic', 'vibrant', 'ethereal'];
        const details = ['with soft lighting', 'with bold colors', 'in pastel tones', 'with intricate details', 'with geometric patterns'];

        if (basePrompt) {
            return `${basePrompt}, ${styles[Math.floor(Math.random() * styles.length)]} style, ${moods[Math.floor(Math.random() * moods.length)]} mood`;
        }

        return `A ${moods[Math.floor(Math.random() * moods.length)]} ${subjects[Math.floor(Math.random() * subjects.length)]}, ${styles[Math.floor(Math.random() * styles.length)]} style, ${details[Math.floor(Math.random() * details.length)]}`;
    }

    async simulateGeneration(prompt, rotation = 0) {
        await new Promise(resolve => setTimeout(resolve, 2000));

        const imageId = 'mock-' + Date.now();
        const width = (rotation === 90 || rotation === 270) ? 533 : 400;
        const height = (rotation === 90 || rotation === 270) ? 400 : 533;

        const base64 = this.generateArtisticImage(prompt, width, height);

        const imageData = {
            imageId,
            originalImage: base64,
            originalImageMime: 'image/png',
            originalPrompt: prompt,
            thumbnail: base64,
            timestamp: Date.now()
        };

        this.storage.images.set(imageId, imageData);
        this.storage.currentImage = {
            imageId,
            originalImage: base64,
            originalImageMime: 'image/png',
            originalPrompt: prompt,
            timestamp: Date.now()
        };

        this.storage.history.unshift({
            imageId,
            thumbnail: base64,
            timestamp: Date.now()
        });

        if (this.storage.history.length > 20) {
            this.storage.history = this.storage.history.slice(0, 20);
        }

        return { imageId, current: this.storage.currentImage };
    }

    async handleRequest(method, path, body = null) {
        console.log(`[MockAPI] ${method} ${path}`, body);

        if (path === '/api/settings' && method === 'GET') {
            return this.storage.settings;
        }
        if (path === '/api/settings' && method === 'PUT') {
            this.storage.settings = { ...this.storage.settings, ...body };
            return { success: true };
        }

        if (path === '/api/current-full.json' && method === 'GET') {
            return {
                ...this.storage.currentImage,
                deviceStatus: this.storage.devices['esp32-001']
            };
        }

        if (path === '/api/generate-art' && method === 'POST') {
            return await this.simulateGeneration(body.prompt, body.rotation);
        }

        if (path === '/api/lucky-prompt' && method === 'POST') {
            return { prompt: this.generateRandomPrompt(body.currentPrompt) };
        }

        if (path === '/api/upload' && method === 'POST') {
            const imageId = 'upload-' + Date.now();

            // Extract and read the uploaded file
            if (body && body.formData) {
                const formData = body.formData;
                const file = formData.get('image');

                if (file && file instanceof File) {
                    // Read file as base64
                    const base64 = await this.readFileAsBase64(file);

                    // Store the uploaded image
                    const imageData = {
                        imageId,
                        originalImage: base64,
                        originalImageMime: file.type || 'image/png',
                        originalPrompt: `Uploaded: ${file.name}`,
                        thumbnail: base64,
                        timestamp: Date.now()
                    };

                    this.storage.images.set(imageId, imageData);
                    this.storage.currentImage = imageData;

                    // Add to history
                    this.storage.history.unshift({
                        imageId,
                        thumbnail: base64,
                        timestamp: Date.now()
                    });

                    if (this.storage.history.length > 20) {
                        this.storage.history = this.storage.history.slice(0, 20);
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));
                    return { imageId, success: true };
                }
            }

            // Fallback if no file
            await new Promise(resolve => setTimeout(resolve, 1000));
            return { imageId, success: true };
        }

        if (path === '/api/collections' && method === 'GET') {
            return { collections: this.storage.collections };
        }

        if (path.startsWith('/api/collections/') && method === 'GET') {
            const collectionId = path.split('/')[3];
            return {
                id: collectionId,
                artworks: this.generateMockArtworks(collectionId)
            };
        }

        if (path.startsWith('/api/images/') && method === 'GET') {
            const imageId = path.split('/')[3];
            return this.storage.images.get(imageId) || null;
        }

        if (path === '/api/history' && method === 'GET') {
            return this.storage.history;
        }

        if (path.startsWith('/api/history/') && path.endsWith('/') === false && method === 'DELETE') {
            const imageId = path.split('/')[3];
            this.storage.history = this.storage.history.filter(h => h.imageId !== imageId);
            this.storage.images.delete(imageId);

            // Also remove from myCollection if it exists there
            this.storage.myCollection = this.storage.myCollection.filter(item =>
                item.imageId !== imageId && item.id !== imageId
            );

            return { success: true };
        }

        if (path.match(/\/api\/history\/.+\/load/) && method === 'POST') {
            const imageId = path.split('/')[3];
            const image = this.storage.images.get(imageId);
            if (image) {
                this.storage.currentImage = image;
                return { success: true };
            }
            return { error: 'Image not found' };
        }

        if (path === '/api/my-collection' && method === 'GET') {
            return this.storage.myCollection;
        }

        if (path === '/api/my-collection' && method === 'POST') {
            const newItem = {
                id: 'added-' + Date.now(),
                ...body,
                collectionType: 'external',
                addedAt: Date.now()
            };

            // Check if already in collection
            const exists = this.storage.myCollection.find(item =>
                item.imageUrl === newItem.imageUrl || item.id === newItem.id
            );

            if (exists) {
                return { error: 'Artwork already in collection' };
            }

            this.storage.myCollection.unshift(newItem);
            return { success: true, id: newItem.id };
        }

        if (path.startsWith('/api/my-collection/') && method === 'DELETE') {
            const itemId = path.split('/')[3];
            const initialLength = this.storage.myCollection.length;
            this.storage.myCollection = this.storage.myCollection.filter(item => item.id !== itemId);

            if (this.storage.myCollection.length < initialLength) {
                return { success: true };
            }
            return { error: 'Item not found' };
        }

        if (path === '/api/art/import' && method === 'POST') {
            await new Promise(resolve => setTimeout(resolve, 1500));
            const imageId = 'import-' + Date.now();
            this.storage.currentImage = {
                imageId,
                originalImage: body.imageUrl,
                originalImageMime: 'image/png',
                originalPrompt: `${body.title} by ${body.artist}`,
                timestamp: Date.now()
            };
            return { success: true, imageId };
        }

        if (path.startsWith('/api/art/search') && method === 'GET') {
            const allArtworks = [];
            for (const collectionId of ['renaissance-masters', 'impressionists', 'japanese-masters']) {
                allArtworks.push(...this.generateMockArtworks(collectionId));
            }
            return { results: allArtworks.slice(0, 8) };
        }

        if (path === '/api/esp32-status' && method === 'GET') {
            return this.storage.devices['esp32-001'];
        }

        if (path === '/api/system-info' && method === 'GET') {
            return {
                version: 'preview-mock',
                nodeVersion: 'mock-v20.0.0',
                platform: 'browser',
                uptime: 3600
            };
        }

        if (path === '/api/logs' && method === 'GET') {
            return { logs: this.storage.logs };
        }

        if (path === '/api/device-logs' && method === 'GET') {
            return { logs: this.storage.deviceLogs };
        }

        if (path === '/api/client-ip' && method === 'GET') {
            return { ip: '192.168.1.100' };
        }

        return { error: 'Not found' };
    }
}

// Initialize mock API
window.mockAPI = new MockAPI();

// Intercept fetch calls
const originalFetch = window.fetch;
window.fetch = async function(url, options = {}) {
    if (typeof url === 'string' && url.startsWith('/api/')) {
        const method = options.method || 'GET';
        let body = null;

        if (options.body) {
            if (options.body instanceof FormData) {
                // Extract file from FormData for upload
                body = {
                    type: 'file-upload',
                    formData: options.body
                };
            } else if (typeof options.body === 'string') {
                try {
                    body = JSON.parse(options.body);
                } catch (e) {
                    body = options.body;
                }
            } else {
                body = options.body;
            }
        }

        try {
            const data = await window.mockAPI.handleRequest(method, url, body);

            return {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers({ 'Content-Type': 'application/json' }),
                json: async () => data,
                text: async () => JSON.stringify(data),
                blob: async () => new Blob([JSON.stringify(data)], { type: 'application/json' })
            };
        } catch (error) {
            console.error('[MockAPI] Error:', error);
            return {
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                headers: new Headers({ 'Content-Type': 'application/json' }),
                json: async () => ({ error: error.message }),
                text: async () => JSON.stringify({ error: error.message })
            };
        }
    }

    return originalFetch.apply(this, arguments);
};

console.log('[MockAPI] Preview mode activated - generating artistic placeholders');


            // Add preview banner
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', addBanner);
            } else {
                addBanner();
            }

            function addBanner() {
                if (document.querySelector('.preview-banner')) return;

                const banner = document.createElement('div');
                banner.className = 'preview-banner';
                banner.innerHTML = `
                    <style>
                        .preview-banner {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 8px 16px;
                            text-align: center;
                            z-index: 10000;
                            font-size: 0.85rem;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                        }
                        .preview-banner a {
                            color: white;
                            text-decoration: underline;
                        }
                        body {
                            padding-top: 36px !important;
                        }
                    </style>
                    <strong>üöÄ Preview Mode</strong> &nbsp;|&nbsp; This is a demo with mocked API &nbsp;|&nbsp; <a href="https://github.com/CHaerem/Glance" target="_blank">View on GitHub</a>
                `;
                document.body.insertBefore(banner, document.body.firstChild);
            }
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glance - Admin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #ffffff;
            color: #1a1a1a;
            line-height: 1.6;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 40px;
            text-align: center;
        }

        h2 {
            font-size: 1.125rem;
            font-weight: 600;
            margin: 30px 0 16px 0;
            color: #666;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
        }

        /* Device Status */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 40px;
        }

        .status-item {
            background: #f5f5f5;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .status-value {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .status-label {
            color: #666;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .status-online { color: #10b981; }
        .status-offline { color: #6b7280; }

        /* Logs */
        .logs-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 40px;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .logs-title {
            color: #999;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .logs-controls {
            display: flex;
            gap: 8px;
        }

        .log-btn {
            background: #333;
            border: none;
            color: #999;
            font-size: 0.75rem;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-btn:hover {
            background: #444;
            color: #fff;
        }

        .log-output {
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            font-size: 0.75rem;
            color: #e5e5e5;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .log-output::-webkit-scrollbar {
            width: 8px;
        }

        .log-output::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .log-output::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .log-output::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* Back link */
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #999;
            text-decoration: none;
            font-size: 0.85rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #1a1a1a;
        }

        /* System info */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
            margin-bottom: 40px;
        }

        .info-item {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 12px 16px;
        }

        .info-label {
            color: #666;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 0.9rem;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        /* Settings */
        .settings-form {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 40px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            color: #666;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #1a1a1a;
        }

        .form-hint {
            color: #999;
            font-size: 0.75rem;
            margin-top: 4px;
        }

        .btn-primary {
            background: #1a1a1a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-primary:disabled {
            background: #999;
            cursor: not-allowed;
        }

        .success-message {
            color: #10b981;
            font-size: 0.85rem;
            margin-top: 12px;
            display: none;
        }

        .success-message.show {
            display: block;
        }

        .preset-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: #fff;
            border: 1px solid #e5e5e5;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            border-color: #1a1a1a;
            background: #f5f5f5;
        }

        /* Server identification */
        .server-id {
            font-size: 0.75rem;
            color: #999;
            text-align: center;
            margin-bottom: 24px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê back</a>

    <h1>Admin</h1>

    <!-- Server identification -->
    <div class="server-id" id="serverId"></div>

    <h2>Wake Schedule</h2>
    <div class="settings-form">
        <div class="form-group">
            <label class="form-label" for="sleepDuration">Update Interval (minutes)</label>
            <input type="number" id="sleepDuration" class="form-input" min="5" max="1440" step="1" placeholder="60">
            <div class="form-hint">
                ESP32 wakes at clock-aligned intervals. For example, with 30 minutes it wakes at :00 and :30 of each hour, not at random times like 12:02 or 12:32.
            </div>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setSleepPreset(5)">5 min</button>
                <button class="preset-btn" onclick="setSleepPreset(15)">15 min</button>
                <button class="preset-btn" onclick="setSleepPreset(30)">30 min</button>
                <button class="preset-btn" onclick="setSleepPreset(60)">1 hour</button>
                <button class="preset-btn" onclick="setSleepPreset(120)">2 hours</button>
                <button class="preset-btn" onclick="setSleepPreset(360)">6 hours</button>
                <button class="preset-btn" onclick="setSleepPreset(720)">12 hours</button>
                <button class="preset-btn" onclick="setSleepPreset(1440)">24 hours</button>
            </div>
            <div style="margin-top: 12px; padding: 12px; background: #fff; border-radius: 4px; font-size: 0.85rem; color: #666;">
                <strong>Next wake times:</strong> <span id="nextWakeTimes">--</span>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">
                <input type="checkbox" id="devMode" style="margin-right: 8px; width: auto;">
                Development Mode
            </label>
            <div class="form-hint" id="devModeHint">
                ESP32 will try dev server first, fallback to production if unreachable. Auto-disables if dev server is down.
            </div>
        </div>

        <div class="form-group" id="devServerHostGroup" style="display: none;">
            <label class="form-label" for="devServerHost">Development Server Host</label>
            <input type="text" id="devServerHost" class="form-input" placeholder="192.168.1.100:3000">
            <div class="form-hint">
                Your development laptop IP and port (auto-detected).
            </div>
        </div>

        <div class="form-group">
            <label class="form-label" for="defaultOrientation">Default Display Orientation</label>
            <div style="display: flex; gap: 12px;">
                <button type="button" class="preset-btn" id="orientationPortrait" onclick="selectOrientation('portrait')" style="flex: 1;">
                    Portrait (1200√ó1600)
                </button>
                <button type="button" class="preset-btn" id="orientationLandscape" onclick="selectOrientation('landscape')" style="flex: 1;">
                    Landscape (1600√ó1200)
                </button>
            </div>
            <div class="form-hint">
                Default orientation for image previews and AI generation.
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">
                <input type="checkbox" id="nightSleepEnabled" onchange="toggleNightSleepInputs()" style="margin-right: 8px; width: auto;">
                Night Sleep
            </label>
            <div class="form-hint">
                Keep display asleep during nighttime hours.
            </div>
            <div id="nightSleepInputs" style="display: none; margin-top: 12px;">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <div style="flex: 1;">
                        <label class="form-label" for="nightSleepStartHour" style="margin-bottom: 4px;">From</label>
                        <select id="nightSleepStartHour" class="form-input">
                            <option value="0">00:00 (12 AM)</option>
                            <option value="1">01:00 (1 AM)</option>
                            <option value="2">02:00 (2 AM)</option>
                            <option value="3">03:00 (3 AM)</option>
                            <option value="4">04:00 (4 AM)</option>
                            <option value="5">05:00 (5 AM)</option>
                            <option value="6">06:00 (6 AM)</option>
                            <option value="7">07:00 (7 AM)</option>
                            <option value="8">08:00 (8 AM)</option>
                            <option value="9">09:00 (9 AM)</option>
                            <option value="10">10:00 (10 AM)</option>
                            <option value="11">11:00 (11 AM)</option>
                            <option value="12">12:00 (12 PM)</option>
                            <option value="13">13:00 (1 PM)</option>
                            <option value="14">14:00 (2 PM)</option>
                            <option value="15">15:00 (3 PM)</option>
                            <option value="16">16:00 (4 PM)</option>
                            <option value="17">17:00 (5 PM)</option>
                            <option value="18">18:00 (6 PM)</option>
                            <option value="19">19:00 (7 PM)</option>
                            <option value="20">20:00 (8 PM)</option>
                            <option value="21">21:00 (9 PM)</option>
                            <option value="22">22:00 (10 PM)</option>
                            <option value="23">23:00 (11 PM)</option>
                        </select>
                    </div>
                    <div style="padding-top: 20px; color: #999;">‚Äî</div>
                    <div style="flex: 1;">
                        <label class="form-label" for="nightSleepEndHour" style="margin-bottom: 4px;">To</label>
                        <select id="nightSleepEndHour" class="form-input">
                            <option value="0">00:00 (12 AM)</option>
                            <option value="1">01:00 (1 AM)</option>
                            <option value="2">02:00 (2 AM)</option>
                            <option value="3">03:00 (3 AM)</option>
                            <option value="4">04:00 (4 AM)</option>
                            <option value="5">05:00 (5 AM)</option>
                            <option value="6">06:00 (6 AM)</option>
                            <option value="7">07:00 (7 AM)</option>
                            <option value="8">08:00 (8 AM)</option>
                            <option value="9">09:00 (9 AM)</option>
                            <option value="10">10:00 (10 AM)</option>
                            <option value="11">11:00 (11 AM)</option>
                            <option value="12">12:00 (12 PM)</option>
                            <option value="13">13:00 (1 PM)</option>
                            <option value="14">14:00 (2 PM)</option>
                            <option value="15">15:00 (3 PM)</option>
                            <option value="16">16:00 (4 PM)</option>
                            <option value="17">17:00 (5 PM)</option>
                            <option value="18">18:00 (6 PM)</option>
                            <option value="19">19:00 (7 PM)</option>
                            <option value="20">20:00 (8 PM)</option>
                            <option value="21">21:00 (9 PM)</option>
                            <option value="22">22:00 (10 PM)</option>
                            <option value="23">23:00 (11 PM)</option>
                        </select>
                    </div>
                </div>
                <div class="form-hint" style="margin-top: 8px;">
                    Display stays asleep during selected hours.
                </div>
            </div>
        </div>

        <button class="btn-primary" onclick="saveSettings()">Save Settings</button>
        <div class="success-message" id="successMessage">Settings saved! ESP32 will use new settings on next wake.</div>
    </div>

    <h2>Device Status</h2>
    <div class="status-grid">
        <div class="status-item">
            <div class="status-value" id="deviceState">--</div>
            <div class="status-label">Status</div>
        </div>
        <div class="status-item">
            <div class="status-value" id="batteryVoltage">--V</div>
            <div class="status-label">Battery</div>
        </div>
        <div class="status-item">
            <div class="status-value" id="lastCharged">--</div>
            <div class="status-label">Last Charged</div>
        </div>
        <div class="status-item">
            <div class="status-value" id="signalStrength">--</div>
            <div class="status-label">Signal</div>
        </div>
        <div class="status-item">
            <div class="status-value" id="nextWake">--</div>
            <div class="status-label">Next Update</div>
        </div>
    </div>

    <h2>System Information</h2>
    <div class="info-grid">
        <div class="info-item">
            <div class="info-label">Server Version</div>
            <div class="info-value" id="serverVersion">--</div>
        </div>
        <div class="info-item">
            <div class="info-label">Node.js Version</div>
            <div class="info-value" id="nodeVersion">--</div>
        </div>
        <div class="info-item">
            <div class="info-label">Uptime</div>
            <div class="info-value" id="uptime">--</div>
        </div>
        <div class="info-item">
            <div class="info-label">Platform</div>
            <div class="info-value" id="platform">--</div>
        </div>
    </div>

    <h2>Device Logs</h2>
    <div class="logs-container">
        <div class="logs-header">
            <div class="logs-title">ESP32 Activity</div>
            <div class="logs-controls">
                <button class="log-btn" onclick="refreshDeviceLogs()">Refresh</button>
                <button class="log-btn" onclick="clearDeviceLogs()">Clear</button>
            </div>
        </div>
        <div class="log-output" id="deviceLogOutput">Loading device logs...</div>
    </div>

    <h2>Server Logs</h2>
    <div class="logs-container">
        <div class="logs-header">
            <div class="logs-title">Console Output</div>
            <div class="logs-controls">
                <button class="log-btn" onclick="refreshLogs()">Refresh</button>
                <button class="log-btn" onclick="clearLogs()">Clear</button>
                <button class="log-btn" id="autoRefreshBtn" onclick="toggleAutoRefresh()">Auto: Off</button>
            </div>
        </div>
        <div class="log-output" id="logOutput">Loading logs...</div>
    </div>

    <script>
        let autoRefreshInterval = null;
        let selectedOrientation = 'portrait'; // Default orientation

        // Select orientation
        function selectOrientation(orientation) {
            selectedOrientation = orientation;

            // Update button styles
            const portraitBtn = document.getElementById('orientationPortrait');
            const landscapeBtn = document.getElementById('orientationLandscape');

            if (orientation === 'portrait') {
                portraitBtn.style.background = '#1a1a1a';
                portraitBtn.style.color = '#fff';
                landscapeBtn.style.background = '';
                landscapeBtn.style.color = '';
            } else {
                landscapeBtn.style.background = '#1a1a1a';
                landscapeBtn.style.color = '#fff';
                portraitBtn.style.background = '';
                portraitBtn.style.color = '';
            }
        }

        // Load settings
        async function loadSettings() {
            try {
                const response = await fetch('/api/settings');
                const settings = await response.json();

                // Convert microseconds to minutes
                const minutes = Math.round(settings.defaultSleepDuration / 1000000 / 60);
                document.getElementById('sleepDuration').value = minutes;

                // Load dev mode settings (default to true if not set)
                const devMode = settings.devMode !== undefined ? settings.devMode : true;
                document.getElementById('devMode').checked = devMode;
                document.getElementById('devServerHost').value = settings.devServerHost || '';

                // Load orientation setting (default to portrait if not set)
                const orientation = settings.defaultOrientation || 'portrait';
                selectOrientation(orientation);

                // Load night sleep settings (default to disabled)
                const nightSleepEnabled = settings.nightSleepEnabled || false;
                document.getElementById('nightSleepEnabled').checked = nightSleepEnabled;
                document.getElementById('nightSleepStartHour').value = settings.nightSleepStartHour || 23;
                document.getElementById('nightSleepEndHour').value = settings.nightSleepEndHour || 5;
                toggleNightSleepInputs();

                // Show/hide dev server host field based on dev mode
                toggleDevServerHost();

                // Calculate and show next wake times
                updateNextWakeTimes(minutes);
            } catch (error) {
                console.error('Failed to load settings:', error);
            }
        }

        // Initialize server identification
        function initServerId() {
            const serverId = document.getElementById('serverId');
            const hostname = window.location.hostname;
            const isProduction = hostname.includes('serverpi') || hostname.includes('raspberrypi');

            if (isProduction) {
                serverId.textContent = 'production: ' + window.location.host;
            } else {
                serverId.textContent = 'development: ' + window.location.host;

                // Hide dev mode settings on development server
                // (only production server should control where ESP32 connects)
                const devModeGroup = document.querySelector('.form-group:has(#devMode)');
                const devServerHostGroup = document.getElementById('devServerHostGroup');
                if (devModeGroup) devModeGroup.style.display = 'none';
                if (devServerHostGroup) devServerHostGroup.style.display = 'none';
            }
        }

        // Toggle dev server host visibility and auto-fill IP
        async function toggleDevServerHost() {
            const devMode = document.getElementById('devMode').checked;
            const hostGroup = document.getElementById('devServerHostGroup');
            const hostInput = document.getElementById('devServerHost');

            hostGroup.style.display = devMode ? 'block' : 'none';

            // Auto-fill client IP when toggling dev mode ON
            if (devMode && !hostInput.value) {
                try {
                    const response = await fetch('/api/client-ip');
                    const data = await response.json();
                    if (data.ip && !data.ip.startsWith('::')) {
                        hostInput.value = data.ip + ':3000';
                        hostInput.placeholder = data.ip + ':3000';
                    }
                } catch (error) {
                    console.log('Could not auto-detect IP:', error);
                }
            }
        }

        // Toggle night sleep inputs visibility
        function toggleNightSleepInputs() {
            const enabled = document.getElementById('nightSleepEnabled').checked;
            const inputs = document.getElementById('nightSleepInputs');
            inputs.style.display = enabled ? 'block' : 'none';
        }

        // Calculate and display next wake times
        function updateNextWakeTimes(intervalMinutes) {
            if (!intervalMinutes || intervalMinutes < 5) {
                document.getElementById('nextWakeTimes').textContent = '--';
                return;
            }

            const now = new Date();
            const intervalMs = intervalMinutes * 60 * 1000;
            const nowMs = now.getTime();

            // Calculate next 3 wake times
            const msSinceLastInterval = nowMs % intervalMs;
            const msUntilNext = intervalMs - msSinceLastInterval;

            const wakeTimes = [];
            for (let i = 0; i < 3; i++) {
                const wakeTime = new Date(nowMs + msUntilNext + (i * intervalMs));
                const timeStr = wakeTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                wakeTimes.push(timeStr);
            }

            document.getElementById('nextWakeTimes').textContent = wakeTimes.join(', ');
        }

        // Add event listener to dev mode checkbox
        document.addEventListener('DOMContentLoaded', () => {
            initServerId();
            document.getElementById('devMode').addEventListener('change', toggleDevServerHost);
        });

        // Set preset value
        function setSleepPreset(minutes) {
            document.getElementById('sleepDuration').value = minutes;
            updateNextWakeTimes(minutes);
        }

        // Save settings
        async function saveSettings() {
            try {
                const minutes = parseInt(document.getElementById('sleepDuration').value);

                if (!minutes || minutes < 5 || minutes > 1440) {
                    alert('Please enter a value between 5 and 1440 minutes');
                    return;
                }

                // Convert minutes to microseconds
                const microseconds = minutes * 60 * 1000000;

                // Get dev mode settings
                const devMode = document.getElementById('devMode').checked;
                const devServerHost = document.getElementById('devServerHost').value.trim();

                // Get night sleep settings
                const nightSleepEnabled = document.getElementById('nightSleepEnabled').checked;
                const nightSleepStartHour = parseInt(document.getElementById('nightSleepStartHour').value) || 23;
                const nightSleepEndHour = parseInt(document.getElementById('nightSleepEndHour').value) || 5;

                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        defaultSleepDuration: microseconds,
                        devMode: devMode,
                        devServerHost: devServerHost || undefined,
                        defaultOrientation: selectedOrientation,
                        nightSleepEnabled: nightSleepEnabled,
                        nightSleepStartHour: nightSleepStartHour,
                        nightSleepEndHour: nightSleepEndHour
                    })
                });

                if (response.ok) {
                    const successMsg = document.getElementById('successMessage');
                    successMsg.classList.add('show');
                    setTimeout(() => successMsg.classList.remove('show'), 3000);
                } else {
                    const error = await response.json();
                    alert('Failed to save settings: ' + error.error);
                }
            } catch (error) {
                console.error('Failed to save settings:', error);
                alert('Failed to save settings');
            }
        }

        // Load device status
        async function loadDeviceStatus() {
            try {
                const response = await fetch('/api/esp32-status');
                const status = await response.json();

                document.getElementById('deviceState').textContent = status.state || 'Unknown';
                document.getElementById('deviceState').className =
                    status.state === 'online' ? 'status-value status-online' : 'status-value status-offline';

                // Battery display with percentage and charging indicator
                if (status.batteryVoltage) {
                    let batteryText = `${status.batteryVoltage}V`;
                    if (status.batteryPercent !== null && status.batteryPercent !== undefined) {
                        batteryText += ` (${status.batteryPercent}%)`;
                    }
                    if (status.isCharging) {
                        batteryText += ' ‚ö°';
                    }
                    document.getElementById('batteryVoltage').textContent = batteryText;
                } else {
                    document.getElementById('batteryVoltage').textContent = '--';
                }

                // Last charged display
                if (status.lastChargeTimestamp) {
                    const lastCharge = new Date(status.lastChargeTimestamp);
                    const now = new Date();
                    const diffMinutes = Math.floor((now - lastCharge) / 1000 / 60);

                    if (diffMinutes < 1) {
                        document.getElementById('lastCharged').textContent = 'Just now';
                    } else if (diffMinutes < 60) {
                        document.getElementById('lastCharged').textContent = `${diffMinutes}m ago`;
                    } else if (diffMinutes < 1440) { // Less than 24 hours
                        const hours = Math.floor(diffMinutes / 60);
                        document.getElementById('lastCharged').textContent = `${hours}h ago`;
                    } else {
                        const days = Math.floor(diffMinutes / 1440);
                        document.getElementById('lastCharged').textContent = `${days}d ago`;
                    }
                } else {
                    document.getElementById('lastCharged').textContent = 'Never';
                }

                document.getElementById('signalStrength').textContent =
                    status.signalStrength ? `${status.signalStrength} dBm` : '--';

                // Calculate next wake time
                if (status.lastSeen && status.sleepDuration) {
                    const lastSeen = status.lastSeen;
                    const sleepDurationMs = status.sleepDuration / 1000; // Convert microseconds to milliseconds
                    const nextWakeTime = lastSeen + sleepDurationMs;
                    const now = Date.now();
                    const diffMs = nextWakeTime - now;

                    if (diffMs > 0) {
                        // Future wake time
                        const diffMinutes = Math.floor(diffMs / 1000 / 60);
                        if (diffMinutes < 1) {
                            document.getElementById('nextWake').textContent = 'Soon';
                        } else if (diffMinutes < 60) {
                            document.getElementById('nextWake').textContent = `${diffMinutes}m`;
                        } else {
                            const hours = Math.floor(diffMinutes / 60);
                            const minutes = diffMinutes % 60;
                            document.getElementById('nextWake').textContent = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                        }
                    } else {
                        // Past due (should have woken already)
                        const overdue = Math.floor(Math.abs(diffMs) / 1000 / 60);
                        document.getElementById('nextWake').textContent = overdue < 2 ? 'Now' : `Overdue ${overdue}m`;
                    }
                } else {
                    document.getElementById('nextWake').textContent = '--';
                }
            } catch (error) {
                console.error('Failed to load device status:', error);
            }
        }

        // Load system info
        async function loadSystemInfo() {
            try {
                const response = await fetch('/api/system-info');
                const info = await response.json();

                // Format version with GitHub link if it's a SHA
                const versionEl = document.getElementById('serverVersion');
                const version = info.version || 'local';

                if (version.startsWith('sha-')) {
                    const sha = version.substring(4); // Remove 'sha-' prefix
                    versionEl.innerHTML = `<a href="https://github.com/CHaerem/Glance/commit/${sha}" target="_blank" style="color: #0969da; text-decoration: none;">${version}</a>`;
                } else {
                    versionEl.textContent = version;
                }

                document.getElementById('nodeVersion').textContent = info.nodeVersion || process.version;
                document.getElementById('platform').textContent = info.platform || navigator.platform;

                if (info.uptime) {
                    const hours = Math.floor(info.uptime / 3600);
                    const minutes = Math.floor((info.uptime % 3600) / 60);
                    document.getElementById('uptime').textContent = `${hours}h ${minutes}m`;
                }
            } catch (error) {
                console.error('Failed to load system info:', error);
            }
        }

        // Load device logs
        async function loadDeviceLogs() {
            try {
                const response = await fetch('/api/device-logs');
                const data = await response.json();

                const logOutput = document.getElementById('deviceLogOutput');
                if (data.logs && data.logs.length > 0) {
                    logOutput.textContent = data.logs.join('\n');
                    // Auto-scroll to bottom
                    logOutput.scrollTop = logOutput.scrollHeight;
                } else {
                    logOutput.textContent = 'No device activity yet';
                }
            } catch (error) {
                console.error('Failed to load device logs:', error);
                document.getElementById('deviceLogOutput').textContent = 'Error loading device logs';
            }
        }

        function refreshDeviceLogs() {
            loadDeviceLogs();
        }

        function clearDeviceLogs() {
            document.getElementById('deviceLogOutput').textContent = '';
        }

        // Load server logs
        async function loadLogs() {
            try {
                const response = await fetch('/api/logs');
                const data = await response.json();

                const logOutput = document.getElementById('logOutput');
                if (data.logs && data.logs.length > 0) {
                    logOutput.textContent = data.logs.join('\n');
                    // Auto-scroll to bottom
                    logOutput.scrollTop = logOutput.scrollHeight;
                } else {
                    logOutput.textContent = 'No logs available';
                }
            } catch (error) {
                console.error('Failed to load logs:', error);
                document.getElementById('logOutput').textContent = 'Error loading logs';
            }
        }

        function refreshLogs() {
            loadLogs();
        }

        function clearLogs() {
            document.getElementById('logOutput').textContent = '';
        }

        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                btn.textContent = 'Auto: Off';
            } else {
                autoRefreshInterval = setInterval(() => {
                    loadLogs();
                    loadDeviceLogs();
                    loadDeviceStatus();
                }, 2000);
                btn.textContent = 'Auto: On';
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            loadDeviceStatus();
            loadSystemInfo();
            loadLogs();
            loadDeviceLogs();
            setInterval(loadDeviceStatus, 5000); // Update status every 5s
        });
    </script>
</body>
</html>
