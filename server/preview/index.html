<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Inline mock API for preview mode (must load synchronously) -->
    <script>
        // Auto-detect preview mode
        (function() {
            const isGitHubPages = window.location.hostname.includes('github.io');
            const isLocalFile = window.location.protocol === 'file:';

            if (!isGitHubPages && !isLocalFile) {
                console.log('[Preview] Production mode - using real backend');
                return;
            }

            console.log('[Preview] Mock mode activated');

            // Load mock API immediately (synchronously)
            /**
 * Mock API Server for GitHub Pages Preview
 *
 * Enhanced version with visually rich placeholder generation
 * for proper UX/design testing
 */

class MockAPI {
    constructor() {
        this.storage = {
            settings: {
                defaultSleepDuration: 3600000000,
                devMode: false,
                devServerHost: '',
                defaultOrientation: 'portrait',
                nightSleepEnabled: false,
                nightSleepStartHour: 23,
                nightSleepEndHour: 5
            },
            currentImage: {
                imageId: 'demo-001',
                originalImage: null,
                originalImageMime: 'image/png',
                originalPrompt: 'A serene landscape with mountains and a lake at sunset',
                timestamp: Date.now() - 3600000
            },
            images: new Map(),
            history: [],
            devices: {
                'esp32-001': {
                    deviceId: 'esp32-001',
                    state: 'sleeping',
                    batteryVoltage: 4.1,
                    batteryPercent: 85,
                    isCharging: false,
                    lastChargeTimestamp: Date.now() - 7200000,
                    signalStrength: -45,
                    lastSeen: Date.now() - 1800000,
                    sleepDuration: 3600000000,
                    status: 'sleeping'
                }
            },
            logs: [
                '[2025-10-30 10:15:32] Server started',
                '[2025-10-30 10:15:33] Mock API initialized',
                '[2025-10-30 10:16:45] ESP32 connected',
                '[2025-10-30 10:17:12] Image generated: demo-001'
            ],
            deviceLogs: [
                '[2025-10-30 10:16:45] ESP32 woke up',
                '[2025-10-30 10:16:46] Connected to WiFi',
                '[2025-10-30 10:16:47] Battery: 4.1V (85%)',
                '[2025-10-30 10:17:12] Display refresh complete',
                '[2025-10-30 10:17:13] Entering deep sleep for 60 minutes'
            ],
            collections: this.generateMockCollections(),
            myCollection: []
        };

        this.generateDemoImage();
        this.initializeMyCollection();
    }

    /**
     * Generate visually rich placeholder based on prompt
     */
    generateArtisticImage(prompt, width = 400, height = 533) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        // Extract style hints from prompt
        const lowerPrompt = prompt.toLowerCase();
        let style = 'abstract';

        if (lowerPrompt.includes('landscape') || lowerPrompt.includes('mountain') || lowerPrompt.includes('lake')) {
            style = 'landscape';
        } else if (lowerPrompt.includes('portrait') || lowerPrompt.includes('face') || lowerPrompt.includes('person')) {
            style = 'portrait';
        } else if (lowerPrompt.includes('geometric') || lowerPrompt.includes('pattern')) {
            style = 'geometric';
        } else if (lowerPrompt.includes('minimal')) {
            style = 'minimal';
        }

        // Generate based on style
        switch(style) {
            case 'landscape':
                this.drawLandscape(ctx, width, height, prompt);
                break;
            case 'portrait':
                this.drawPortrait(ctx, width, height, prompt);
                break;
            case 'geometric':
                this.drawGeometric(ctx, width, height, prompt);
                break;
            case 'minimal':
                this.drawMinimal(ctx, width, height, prompt);
                break;
            default:
                this.drawAbstract(ctx, width, height, prompt);
        }

        // Add subtle prompt text at bottom
        this.addPromptOverlay(ctx, width, height, prompt);

        return canvas.toDataURL('image/png').split(',')[1];
    }

    drawLandscape(ctx, width, height, prompt) {
        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.6);
        skyGradient.addColorStop(0, '#87CEEB');
        skyGradient.addColorStop(0.5, '#B0E0E6');
        skyGradient.addColorStop(1, '#FFE4B5');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height * 0.6);

        // Mountains in layers
        const mountainLayers = [
            { y: height * 0.4, color: '#4A5568', points: 5 },
            { y: height * 0.45, color: '#718096', points: 6 },
            { y: height * 0.5, color: '#A0AEC0', points: 7 }
        ];

        mountainLayers.forEach(layer => {
            ctx.fillStyle = layer.color;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.6);

            for (let i = 0; i <= layer.points; i++) {
                const x = (width / layer.points) * i;
                const peakHeight = layer.y + (Math.sin(i * 1.5) * height * 0.1);
                ctx.lineTo(x, peakHeight);
            }

            ctx.lineTo(width, height * 0.6);
            ctx.closePath();
            ctx.fill();
        });

        // Foreground - grass/lake
        const groundGradient = ctx.createLinearGradient(0, height * 0.6, 0, height);
        if (prompt.toLowerCase().includes('lake')) {
            groundGradient.addColorStop(0, '#4682B4');
            groundGradient.addColorStop(1, '#1E3A5F');
        } else {
            groundGradient.addColorStop(0, '#90EE90');
            groundGradient.addColorStop(1, '#228B22');
        }
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, height * 0.6, width, height * 0.4);

        // Sun/Moon
        ctx.fillStyle = prompt.toLowerCase().includes('sunset') ? '#FF6347' : '#FFD700';
        ctx.beginPath();
        ctx.arc(width * 0.8, height * 0.2, 30, 0, Math.PI * 2);
        ctx.fill();

        // Add some trees
        for (let i = 0; i < 5; i++) {
            const treeX = (width / 6) * (i + 1) + (Math.random() * 20 - 10);
            const treeY = height * 0.6 + (Math.random() * height * 0.1);
            this.drawTree(ctx, treeX, treeY, 15 + Math.random() * 10);
        }
    }

    drawTree(ctx, x, y, size) {
        // Trunk
        ctx.fillStyle = '#654321';
        ctx.fillRect(x - size * 0.1, y, size * 0.2, size);

        // Foliage
        ctx.fillStyle = '#228B22';
        ctx.beginPath();
        ctx.moveTo(x, y - size * 0.5);
        ctx.lineTo(x - size * 0.4, y + size * 0.2);
        ctx.lineTo(x + size * 0.4, y + size * 0.2);
        ctx.closePath();
        ctx.fill();
    }

    drawPortrait(ctx, width, height) {
        // Background
        const bgGradient = ctx.createRadialGradient(width/2, height/3, 0, width/2, height/3, width);
        bgGradient.addColorStop(0, '#FFF5E1');
        bgGradient.addColorStop(1, '#D2B48C');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);

        // Head
        const centerX = width / 2;
        const centerY = height * 0.4;
        const headRadius = width * 0.25;

        ctx.fillStyle = '#FFDAB9';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, headRadius * 0.8, headRadius, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = '#4A2C2A';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY - headRadius * 0.3, headRadius * 0.85, headRadius * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#2C3E50';
        ctx.beginPath();
        ctx.arc(centerX - headRadius * 0.3, centerY - headRadius * 0.1, headRadius * 0.08, 0, Math.PI * 2);
        ctx.arc(centerX + headRadius * 0.3, centerY - headRadius * 0.1, headRadius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Nose
        ctx.strokeStyle = '#B8956A';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX - headRadius * 0.05, centerY + headRadius * 0.15);
        ctx.stroke();

        // Mouth
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY + headRadius * 0.3, headRadius * 0.3, 0.2, Math.PI - 0.2);
        ctx.stroke();

        // Shoulders
        ctx.fillStyle = '#4682B4';
        ctx.beginPath();
        ctx.moveTo(centerX - headRadius * 1.2, height);
        ctx.lineTo(centerX - headRadius * 0.6, centerY + headRadius);
        ctx.lineTo(centerX + headRadius * 0.6, centerY + headRadius);
        ctx.lineTo(centerX + headRadius * 1.2, height);
        ctx.closePath();
        ctx.fill();
    }

    drawGeometric(ctx, width, height) {
        // Clean background
        ctx.fillStyle = '#F5F5F5';
        ctx.fillRect(0, 0, width, height);

        // Generate geometric pattern
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];
        const shapes = Math.floor(Math.random() * 10) + 15;

        for (let i = 0; i < shapes; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 80 + 40;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const shape = Math.floor(Math.random() * 3);

            ctx.fillStyle = color + '80'; // Add transparency
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            switch(shape) {
                case 0: // Circle
                    ctx.arc(x, y, size/2, 0, Math.PI * 2);
                    break;
                case 1: // Square
                    ctx.rect(x - size/2, y - size/2, size, size);
                    break;
                case 2: // Triangle
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.closePath();
                    break;
            }
            ctx.fill();
            ctx.stroke();
        }
    }

    drawMinimal(ctx, width, height) {
        // White background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, width, height);

        // Single focal element
        const centerX = width / 2;
        const centerY = height / 2;

        // Large circle
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.min(width, height) * 0.3, 0, Math.PI * 2);
        ctx.stroke();

        // Smaller circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.min(width, height) * 0.15, 0, Math.PI * 2);
        ctx.stroke();

        // Line through
        ctx.beginPath();
        ctx.moveTo(centerX - width * 0.3, centerY);
        ctx.lineTo(centerX + width * 0.3, centerY);
        ctx.stroke();
    }

    drawAbstract(ctx, width, height) {
        // Colorful gradient background
        const hue1 = Math.random() * 360;
        const hue2 = (hue1 + 120) % 360;
        const hue3 = (hue1 + 240) % 360;

        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, `hsl(${hue1}, 70%, 60%)`);
        gradient.addColorStop(0.5, `hsl(${hue2}, 70%, 60%)`);
        gradient.addColorStop(1, `hsl(${hue3}, 70%, 60%)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Organic shapes
        const shapes = Math.floor(Math.random() * 5) + 8;
        for (let i = 0; i < shapes; i++) {
            ctx.fillStyle = `hsla(${Math.random() * 360}, 60%, 70%, 0.4)`;
            ctx.beginPath();

            const centerX = Math.random() * width;
            const centerY = Math.random() * height;
            const radius = Math.random() * 100 + 50;

            // Blob shape
            for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
                const wobble = Math.random() * 20 + radius;
                const x = centerX + Math.cos(angle) * wobble;
                const y = centerY + Math.sin(angle) * wobble;
                if (angle === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
        }
    }

    addPromptOverlay(ctx, width, height, prompt) {
        // Semi-transparent overlay at bottom
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, height - 60, width, 60);

        // Prompt text
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Truncate prompt if too long
        let displayPrompt = prompt;
        if (prompt.length > 50) {
            displayPrompt = prompt.substring(0, 47) + '...';
        }

        ctx.fillText(displayPrompt, width / 2, height - 30);
    }

    generateDemoImage() {
        // Generate a rich history of varied images
        const demoPrompts = [
            'A serene landscape with mountains and a lake at sunset',
            'Minimalist geometric pattern with circles',
            'Abstract colorful art with organic shapes',
            'Portrait of a person in contemplation',
            'Japanese landscape with Mount Fuji',
            'Geometric pattern with triangles and squares',
            'Mountain landscape at dawn with morning mist',
            'Minimalist design with simple lines',
            'Abstract expressionist artwork',
            'Peaceful lake scene with reflections',
            'Portrait in renaissance style',
            'Colorful geometric composition'
        ];

        // Generate images in reverse chronological order
        const now = Date.now();
        const hoursAgo = [0.5, 2, 5, 12, 24, 48, 72, 96, 120, 168, 240, 336]; // Hours ago

        demoPrompts.forEach((prompt, index) => {
            const imageId = `demo-${String(index + 1).padStart(3, '0')}`;
            const timestamp = now - (hoursAgo[index] * 3600000);

            const base64 = this.generateArtisticImage(prompt, 400, 533);

            const imageData = {
                imageId,
                originalImage: base64,
                originalImageMime: 'image/png',
                originalPrompt: prompt,
                thumbnail: base64,
                timestamp
            };

            this.storage.images.set(imageId, imageData);
            this.storage.history.push({
                imageId,
                thumbnail: base64,
                timestamp
            });
        });

        // Most recent image becomes current
        const latest = this.storage.history[0];
        const latestImage = this.storage.images.get(latest.imageId);
        this.storage.currentImage = {
            imageId: latestImage.imageId,
            originalImage: latestImage.originalImage,
            originalImageMime: latestImage.originalImageMime,
            originalPrompt: latestImage.originalPrompt,
            timestamp: latestImage.timestamp
        };

        console.log(`[MockAPI] Generated ${demoPrompts.length} demo images for history`);
    }

    initializeMyCollection() {
        // Initialize collection with mix of generated and external artworks
        const now = Date.now();

        // Add some generated images to collection
        const generatedImages = Array.from(this.storage.images.values()).slice(0, 3);
        generatedImages.forEach((img, index) => {
            this.storage.myCollection.push({
                id: img.imageId,
                imageId: img.imageId,
                thumbnail: img.thumbnail,
                originalImage: img.originalImage,
                originalImageMime: img.originalImageMime,
                title: img.originalPrompt.substring(0, 50),
                originalPrompt: img.originalPrompt,
                artist: 'Generated',
                collectionType: 'generated',
                addedAt: now - (index * 3600000),
                timestamp: img.timestamp
            });
        });

        // Add some external artworks
        const externalArtworks = [
            {
                id: 'external-1',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Tsunami_by_hokusai_19th_century.jpg/400px-Tsunami_by_hokusai_19th_century.jpg',
                title: 'The Great Wave off Kanagawa',
                artist: 'Katsushika Hokusai',
                year: '1831',
                thumbnail: this.generatePlaceholderSVG('Hokusai', '#1a6c9c'),
                collectionType: 'external',
                addedAt: now - 4 * 3600000
            },
            {
                id: 'external-2',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/400px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg',
                title: 'The Starry Night',
                artist: 'Vincent van Gogh',
                year: '1889',
                thumbnail: this.generatePlaceholderSVG('Van Gogh', '#4a5f8c'),
                collectionType: 'external',
                addedAt: now - 8 * 3600000
            },
            {
                id: 'external-3',
                imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Michelangelo_-_Creation_of_Adam_%28cropped%29.jpg/400px-Michelangelo_-_Creation_of_Adam_%28cropped%29.jpg',
                title: 'The Creation of Adam',
                artist: 'Michelangelo',
                year: '1512',
                thumbnail: this.generatePlaceholderSVG('Michelangelo', '#8b7355'),
                collectionType: 'external',
                addedAt: now - 12 * 3600000
            }
        ];

        this.storage.myCollection.push(...externalArtworks);
        console.log(`[MockAPI] Initialized collection with ${this.storage.myCollection.length} items`);
    }

    generatePlaceholderSVG(text, color) {
        const svg = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg"><rect width="200" height="200" fill="${color}"/><text x="100" y="100" font-family="sans-serif" font-size="18" fill="white" text-anchor="middle" dominant-baseline="middle">${text}</text></svg>`;
        return `data:image/svg+xml;base64,${btoa(svg)}`;
    }

    generateMockCollections() {
        return [
            { id: 'renaissance-masters', name: 'Renaissance Masters', description: 'Great works from the Renaissance period' },
            { id: 'dutch-masters', name: 'Dutch Masters', description: 'Dutch Golden Age paintings' },
            { id: 'impressionists', name: 'Impressionists', description: 'French Impressionist masterpieces' },
            { id: 'post-impressionists', name: 'Post-Impressionists', description: 'Post-Impressionist works' },
            { id: 'japanese-masters', name: 'Japanese Masters', description: 'Traditional Japanese art' },
            { id: 'modern-icons', name: 'Modern Icons', description: 'Modern and contemporary art' }
        ];
    }

    generateMockArtworks(collectionId) {
        // Generate visually distinct artwork placeholders
        const artworks = [];
        const artworkData = {
            'renaissance-masters': [
                { title: 'Mona Lisa', artist: 'Leonardo da Vinci', style: 'portrait' },
                { title: 'The Birth of Venus', artist: 'Sandro Botticelli', style: 'portrait' },
                { title: 'The School of Athens', artist: 'Raphael', style: 'geometric' },
                { title: 'The Creation of Adam', artist: 'Michelangelo', style: 'portrait' }
            ],
            'dutch-masters': [
                { title: 'Girl with a Pearl Earring', artist: 'Johannes Vermeer', style: 'portrait' },
                { title: 'The Night Watch', artist: 'Rembrandt', style: 'abstract' },
                { title: 'The Milkmaid', artist: 'Johannes Vermeer', style: 'portrait' }
            ],
            'impressionists': [
                { title: 'Water Lilies', artist: 'Claude Monet', style: 'landscape' },
                { title: 'Bal du moulin de la Galette', artist: 'Pierre-Auguste Renoir', style: 'abstract' },
                { title: 'Impression, Sunrise', artist: 'Claude Monet', style: 'landscape' }
            ],
            'post-impressionists': [
                { title: 'The Starry Night', artist: 'Vincent van Gogh', style: 'landscape' },
                { title: 'The Card Players', artist: 'Paul CÃ©zanne', style: 'portrait' },
                { title: 'A Sunday Afternoon', artist: 'Georges Seurat', style: 'geometric' }
            ],
            'japanese-masters': [
                { title: 'The Great Wave', artist: 'Hokusai', style: 'landscape' },
                { title: 'Red Fuji', artist: 'Hokusai', style: 'landscape' },
                { title: 'Plum Blossoms', artist: 'Hiroshige', style: 'minimal' }
            ],
            'modern-icons': [
                { title: 'The Persistence of Memory', artist: 'Salvador DalÃ­', style: 'abstract' },
                { title: 'Campbell\'s Soup Cans', artist: 'Andy Warhol', style: 'minimal' },
                { title: 'The Scream', artist: 'Edvard Munch', style: 'portrait' }
            ]
        };

        const collectionArt = artworkData[collectionId] || [];

        collectionArt.forEach((art, index) => {
            const prompt = `${art.title} by ${art.artist}, ${art.style} style`;
            const thumbnail = this.generateArtisticImage(prompt, 200, 200);
            const fullImage = this.generateArtisticImage(prompt, 800, 800);

            artworks.push({
                id: `${collectionId}-${index}`,
                title: art.title,
                artist: art.artist,
                thumbnail: `data:image/png;base64,${thumbnail}`,
                imageUrl: `data:image/png;base64,${fullImage}`
            });
        });

        return artworks;
    }

    /**
     * Read file as base64 data URL
     */
    async readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                // Extract base64 part (remove data:image/...;base64, prefix)
                const result = reader.result;
                const base64 = result.split(',')[1];
                resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    generateRandomPrompt(basePrompt = '') {
        const subjects = ['landscape', 'portrait', 'abstract art', 'still life', 'cityscape', 'seascape'];
        const styles = ['impressionist', 'minimalist', 'art nouveau', 'art deco', 'cubist', 'surrealist'];
        const moods = ['serene', 'dramatic', 'whimsical', 'melancholic', 'vibrant', 'ethereal'];
        const details = ['with soft lighting', 'with bold colors', 'in pastel tones', 'with intricate details', 'with geometric patterns'];

        if (basePrompt) {
            return `${basePrompt}, ${styles[Math.floor(Math.random() * styles.length)]} style, ${moods[Math.floor(Math.random() * moods.length)]} mood`;
        }

        return `A ${moods[Math.floor(Math.random() * moods.length)]} ${subjects[Math.floor(Math.random() * subjects.length)]}, ${styles[Math.floor(Math.random() * styles.length)]} style, ${details[Math.floor(Math.random() * details.length)]}`;
    }

    async simulateGeneration(prompt, rotation = 0) {
        await new Promise(resolve => setTimeout(resolve, 2000));

        const imageId = 'mock-' + Date.now();
        const width = (rotation === 90 || rotation === 270) ? 533 : 400;
        const height = (rotation === 90 || rotation === 270) ? 400 : 533;

        const base64 = this.generateArtisticImage(prompt, width, height);

        const imageData = {
            imageId,
            originalImage: base64,
            originalImageMime: 'image/png',
            originalPrompt: prompt,
            thumbnail: base64,
            timestamp: Date.now()
        };

        this.storage.images.set(imageId, imageData);
        this.storage.currentImage = {
            imageId,
            originalImage: base64,
            originalImageMime: 'image/png',
            originalPrompt: prompt,
            timestamp: Date.now()
        };

        this.storage.history.unshift({
            imageId,
            thumbnail: base64,
            timestamp: Date.now()
        });

        if (this.storage.history.length > 20) {
            this.storage.history = this.storage.history.slice(0, 20);
        }

        return { imageId, current: this.storage.currentImage };
    }

    async handleRequest(method, path, body = null) {
        console.log(`[MockAPI] ${method} ${path}`, body);

        if (path === '/api/settings' && method === 'GET') {
            return this.storage.settings;
        }
        if (path === '/api/settings' && method === 'PUT') {
            this.storage.settings = { ...this.storage.settings, ...body };
            return { success: true };
        }

        if (path === '/api/current-full.json' && method === 'GET') {
            return {
                ...this.storage.currentImage,
                deviceStatus: this.storage.devices['esp32-001']
            };
        }

        if (path === '/api/generate-art' && method === 'POST') {
            return await this.simulateGeneration(body.prompt, body.rotation);
        }

        if (path === '/api/lucky-prompt' && method === 'POST') {
            return { prompt: this.generateRandomPrompt(body.currentPrompt) };
        }

        if (path === '/api/upload' && method === 'POST') {
            const imageId = 'upload-' + Date.now();

            // Extract and read the uploaded file
            if (body && body.formData) {
                const formData = body.formData;
                const file = formData.get('image');

                if (file && file instanceof File) {
                    // Read file as base64
                    const base64 = await this.readFileAsBase64(file);

                    // Store the uploaded image
                    const imageData = {
                        imageId,
                        originalImage: base64,
                        originalImageMime: file.type || 'image/png',
                        originalPrompt: `Uploaded: ${file.name}`,
                        thumbnail: base64,
                        timestamp: Date.now()
                    };

                    this.storage.images.set(imageId, imageData);
                    this.storage.currentImage = imageData;

                    // Add to history
                    this.storage.history.unshift({
                        imageId,
                        thumbnail: base64,
                        timestamp: Date.now()
                    });

                    if (this.storage.history.length > 20) {
                        this.storage.history = this.storage.history.slice(0, 20);
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));
                    return { imageId, success: true };
                }
            }

            // Fallback if no file
            await new Promise(resolve => setTimeout(resolve, 1000));
            return { imageId, success: true };
        }

        if (path === '/api/collections' && method === 'GET') {
            return { collections: this.storage.collections };
        }

        if (path.startsWith('/api/collections/') && method === 'GET') {
            const collectionId = path.split('/')[3];
            return {
                id: collectionId,
                artworks: this.generateMockArtworks(collectionId)
            };
        }

        if (path.startsWith('/api/images/') && method === 'GET') {
            const imageId = path.split('/')[3];
            return this.storage.images.get(imageId) || null;
        }

        if (path === '/api/history' && method === 'GET') {
            return this.storage.history;
        }

        if (path.startsWith('/api/history/') && path.endsWith('/') === false && method === 'DELETE') {
            const imageId = path.split('/')[3];
            this.storage.history = this.storage.history.filter(h => h.imageId !== imageId);
            this.storage.images.delete(imageId);

            // Also remove from myCollection if it exists there
            this.storage.myCollection = this.storage.myCollection.filter(item =>
                item.imageId !== imageId && item.id !== imageId
            );

            return { success: true };
        }

        if (path.match(/\/api\/history\/.+\/load/) && method === 'POST') {
            const imageId = path.split('/')[3];
            const image = this.storage.images.get(imageId);
            if (image) {
                this.storage.currentImage = image;
                return { success: true };
            }
            return { error: 'Image not found' };
        }

        if (path === '/api/my-collection' && method === 'GET') {
            return this.storage.myCollection;
        }

        if (path === '/api/my-collection' && method === 'POST') {
            const newItem = {
                id: 'added-' + Date.now(),
                ...body,
                collectionType: 'external',
                addedAt: Date.now()
            };

            // Check if already in collection
            const exists = this.storage.myCollection.find(item =>
                item.imageUrl === newItem.imageUrl || item.id === newItem.id
            );

            if (exists) {
                return { error: 'Artwork already in collection' };
            }

            this.storage.myCollection.unshift(newItem);
            return { success: true, id: newItem.id };
        }

        if (path.startsWith('/api/my-collection/') && method === 'DELETE') {
            const itemId = path.split('/')[3];
            const initialLength = this.storage.myCollection.length;
            this.storage.myCollection = this.storage.myCollection.filter(item => item.id !== itemId);

            if (this.storage.myCollection.length < initialLength) {
                return { success: true };
            }
            return { error: 'Item not found' };
        }

        if (path === '/api/art/import' && method === 'POST') {
            await new Promise(resolve => setTimeout(resolve, 1500));
            const imageId = 'import-' + Date.now();
            this.storage.currentImage = {
                imageId,
                originalImage: body.imageUrl,
                originalImageMime: 'image/png',
                originalPrompt: `${body.title} by ${body.artist}`,
                timestamp: Date.now()
            };
            return { success: true, imageId };
        }

        if (path.startsWith('/api/art/search') && method === 'GET') {
            const allArtworks = [];
            for (const collectionId of ['renaissance-masters', 'impressionists', 'japanese-masters']) {
                allArtworks.push(...this.generateMockArtworks(collectionId));
            }
            return { results: allArtworks.slice(0, 8) };
        }

        if (path === '/api/esp32-status' && method === 'GET') {
            return this.storage.devices['esp32-001'];
        }

        if (path === '/api/system-info' && method === 'GET') {
            return {
                version: 'preview-mock',
                nodeVersion: 'mock-v20.0.0',
                platform: 'browser',
                uptime: 3600
            };
        }

        if (path === '/api/logs' && method === 'GET') {
            return { logs: this.storage.logs };
        }

        if (path === '/api/device-logs' && method === 'GET') {
            return { logs: this.storage.deviceLogs };
        }

        if (path === '/api/client-ip' && method === 'GET') {
            return { ip: '192.168.1.100' };
        }

        return { error: 'Not found' };
    }
}

// Initialize mock API
window.mockAPI = new MockAPI();

// Intercept fetch calls
const originalFetch = window.fetch;
window.fetch = async function(url, options = {}) {
    if (typeof url === 'string' && url.startsWith('/api/')) {
        const method = options.method || 'GET';
        let body = null;

        if (options.body) {
            if (options.body instanceof FormData) {
                // Extract file from FormData for upload
                body = {
                    type: 'file-upload',
                    formData: options.body
                };
            } else if (typeof options.body === 'string') {
                try {
                    body = JSON.parse(options.body);
                } catch (e) {
                    body = options.body;
                }
            } else {
                body = options.body;
            }
        }

        try {
            const data = await window.mockAPI.handleRequest(method, url, body);

            return {
                ok: true,
                status: 200,
                statusText: 'OK',
                headers: new Headers({ 'Content-Type': 'application/json' }),
                json: async () => data,
                text: async () => JSON.stringify(data),
                blob: async () => new Blob([JSON.stringify(data)], { type: 'application/json' })
            };
        } catch (error) {
            console.error('[MockAPI] Error:', error);
            return {
                ok: false,
                status: 500,
                statusText: 'Internal Server Error',
                headers: new Headers({ 'Content-Type': 'application/json' }),
                json: async () => ({ error: error.message }),
                text: async () => JSON.stringify({ error: error.message })
            };
        }
    }

    return originalFetch.apply(this, arguments);
};

console.log('[MockAPI] Preview mode activated - generating artistic placeholders');


            // Add preview banner
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', addBanner);
            } else {
                addBanner();
            }

            function addBanner() {
                if (document.querySelector('.preview-banner')) return;

                const banner = document.createElement('div');
                banner.className = 'preview-banner';
                banner.innerHTML = `
                    <style>
                        .preview-banner {
                            position: fixed;
                            top: 0;
                            left: 0;
                            right: 0;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 8px 16px;
                            text-align: center;
                            z-index: 10000;
                            font-size: 0.85rem;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                        }
                        .preview-banner a {
                            color: white;
                            text-decoration: underline;
                        }
                        body {
                            padding-top: 36px !important;
                        }
                    </style>
                    <strong>ðŸš€ Preview Mode</strong> &nbsp;|&nbsp; This is a demo with mocked API &nbsp;|&nbsp; <a href="https://github.com/CHaerem/Glance" target="_blank">View on GitHub</a>
                `;
                document.body.insertBefore(banner, document.body.firstChild);
            }
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glance - Enhanced</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #ffffff;
            color: #1a1a1a;
            line-height: 1.5;
            min-height: 100vh;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .header {
            margin-bottom: 60px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 300;
            color: #1a1a1a;
            letter-spacing: 2px;
        }

        /* Current Display */
        .current-status {
            margin-bottom: 60px;
            text-align: center;
        }

        #currentImagePreview {
            display: none;
        }

        #currentImagePreview.show {
            display: block;
        }

        #currentImageThumb {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #currentImagePrompt {
            display: none;
            margin-top: 12px;
            padding: 12px 16px;
            background: #fafafa;
            border-left: 2px solid #e5e5e5;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #666;
            line-height: 1.5;
            font-style: italic;
        }

        #currentImagePrompt.show {
            display: block;
        }

        /* Hidden status details by default */
        .esp32-status {
            display: none;
        }

        .esp32-status.show {
            display: block;
        }

        .show-details {
            text-align: center;
            margin-bottom: 40px;
        }

        .details-toggle {
            background: transparent;
            border: none;
            color: #999;
            font-size: 0.75rem;
            cursor: pointer;
            padding: 8px 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: color 0.2s ease;
        }

        .details-toggle:hover {
            color: #666;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .status-item {
            background: #f5f5f5;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .status-value {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .status-label {
            color: #666;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .status-online { color: #10b981; }
        .status-offline { color: #6b7280; }

        /* Main input section */
        .main-input {
            margin-bottom: 40px;
        }

        .input-area {
            position: relative;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            background: #ffffff;
            transition: border-color 0.2s ease;
        }

        .input-area:hover {
            border-color: #999;
        }

        .input-area.dragover {
            border-color: #1a1a1a;
            background: #fafafa;
        }

        .main-textarea {
            width: 100%;
            min-height: 120px;
            padding: 16px;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            color: #1a1a1a;
        }

        .main-textarea:focus {
            outline: none;
        }

        .main-textarea::placeholder {
            color: #999;
        }

        .input-actions {
            display: flex;
            gap: 8px;
            padding: 12px;
            border-top: 1px solid #e5e5e5;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .btn-primary {
            background: #1a1a1a;
            color: #ffffff;
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #1a1a1a;
        }

        .btn-secondary:hover {
            background: #e5e5e5;
        }

        .btn-danger {
            background: #ff3b30;
            color: #ffffff;
        }

        .btn-danger:hover {
            background: #ff2d1f;
        }

        /* Mode toggle */
        .mode-toggle {
            text-align: center;
            margin-bottom: 20px;
        }

        .mode-link {
            background: transparent;
            border: none;
            color: #999;
            font-size: 0.75rem;
            cursor: pointer;
            padding: 8px 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: color 0.2s ease;
        }

        .mode-link:hover {
            color: #666;
        }

        /* Browse mode */
        .browse-section {
            display: none;
        }

        .browse-section.show {
            display: block;
        }

        .search-bar {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #1a1a1a;
        }

        .filter-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 6px 14px;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            background: #ffffff;
            color: #666;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            border-color: #999;
        }

        .filter-btn.active {
            border-color: #1a1a1a;
            color: #1a1a1a;
            background: #f5f5f5;
        }

        .art-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .art-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .art-item:hover {
            transform: translateY(-2px);
        }

        .art-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 4px;
            background: #f5f5f5;
        }

        .art-title {
            font-size: 0.75rem;
            color: #666;
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Show more button (minimal style) */
        .show-more {
            text-align: center;
            margin: 20px 0;
        }

        .show-more-btn {
            background: transparent;
            border: none;
            color: #999;
            font-size: 0.75rem;
            cursor: pointer;
            padding: 8px 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: color 0.2s ease;
        }

        .show-more-btn:hover {
            color: #666;
        }

        /* History */
        .history-section {
            margin-top: 60px;
        }

        .history-toggle {
            text-align: center;
            margin-bottom: 20px;
        }

        .history-toggle-btn {
            background: transparent;
            border: none;
            color: #999;
            font-size: 0.75rem;
            cursor: pointer;
            padding: 8px 16px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: color 0.2s ease;
        }

        .history-toggle-btn:hover {
            color: #666;
        }

        /* History filter tabs */
        .history-filters {
            display: none;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .history-filters.show {
            display: flex;
        }

        .history-grid {
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .history-grid.show {
            display: grid;
        }

        .history-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .history-item:hover {
            transform: translateY(-2px);
        }

        .history-item:hover .item-overlay {
            opacity: 1;
        }

        .history-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 4px;
            background: #f5f5f5;
        }

        /* Hover overlay for metadata */
        .item-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            padding: 8px 6px 4px;
            border-radius: 0 0 4px 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .item-overlay-text {
            font-size: 0.65rem;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-image {
            width: 100%;
            max-height: calc(90vh - 80px);
            border-radius: 8px 8px 0 0;
            aspect-ratio: 3 / 4;
            object-fit: cover;
            object-position: 50% 50%;
            transition: transform 0.2s ease;
            background: #f5f5f5;
        }

        .modal-info {
            padding: 16px;
            background: white;
            border-radius: 0 0 8px 8px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            color: #666;
            transition: all 0.2s ease;
        }

        .close-modal:hover {
            background: white;
            color: #1a1a1a;
        }

        .orientation-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            color: #666;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .orientation-toggle:hover {
            background: white;
            color: #1a1a1a;
            transform: rotate(90deg);
        }

        .modal-image.landscape {
            aspect-ratio: 4 / 3;
        }

        .crop-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 10;
        }

        .crop-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            transition: all 0.2s ease;
            padding: 0;
        }

        .crop-btn:hover {
            background: white;
            color: #1a1a1a;
        }

        .crop-reset {
            margin-top: 4px;
            border-top: 1px solid #eee;
            padding-top: 4px;
        }

        .zoom-controls {
            position: absolute;
            bottom: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 10;
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            color: #666;
            transition: all 0.2s ease;
            padding: 0;
        }

        .zoom-btn:hover {
            background: white;
            color: #1a1a1a;
        }

        .zoom-fit {
            margin-top: 4px;
            border-top: 1px solid #eee;
            padding-top: 4px;
            font-size: 14px;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-size: 0.85rem;
        }

        /* Generation progress overlay */
        .generation-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            z-index: 999;
            align-items: center;
            justify-content: center;
        }

        .generation-overlay.show {
            display: flex;
        }

        .generation-content {
            text-align: center;
            max-width: 400px;
            padding: 40px;
        }

        .generation-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid #e5e5e5;
            border-top-color: #1a1a1a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .generation-status {
            font-size: 1rem;
            color: #1a1a1a;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .generation-prompt {
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
            line-height: 1.5;
        }

        .generation-filename {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
        }

        /* File input hidden */
        #fileInput {
            display: none;
        }

        /* Admin link */
        .admin-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #ccc;
            text-decoration: none;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: color 0.2s ease;
        }

        .admin-link:hover {
            color: #999;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 40px 20px;
            }

            .art-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>GLANCE</h1>
        </div>

        <!-- Current Display -->
        <div class="current-status">
            <div id="currentImagePreview">
                <img id="currentImageThumb" src="" alt="Current display">
                <div id="currentImagePrompt"></div>
            </div>
        </div>

        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button class="mode-link" onclick="switchMode('create')" id="createLink">create</button>
            <span style="color: #e5e5e5;">|</span>
            <button class="mode-link" onclick="switchMode('explore')" id="exploreLink">explore</button>
            <span style="color: #e5e5e5;">|</span>
            <button class="mode-link" onclick="switchMode('my-collection')" id="myCollectionLink">my collection</button>
        </div>

        <!-- Create Mode (default) -->
        <div class="main-input" id="createMode">
            <!-- Generate Section -->
            <div class="input-area">
                <textarea
                    class="main-textarea"
                    id="promptInput"
                    placeholder="Describe the image you want to see..."></textarea>
                <div class="input-actions">
                    <button class="btn btn-primary" onclick="generateArt()">Generate</button>
                    <button class="btn btn-secondary" onclick="feelingLucky()">Feeling Lucky</button>
                </div>
            </div>

            <!-- Separator -->
            <div style="text-align: center; margin: 40px 0 30px; color: #ccc; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">
                or
            </div>

            <!-- Upload Section -->
            <div class="input-area" id="dropZone" style="cursor: pointer;" onclick="document.getElementById('fileInput').click()">
                <div style="padding: 40px 20px; text-align: center;">
                    <div style="color: #999; font-size: 0.9rem; margin-bottom: 8px;">Upload an image</div>
                    <div style="color: #ccc; font-size: 0.75rem;">Click or drag image here</div>
                </div>
            </div>
        </div>

        <!-- Explore Mode -->
        <div class="browse-section" id="exploreMode">
            <div class="search-bar">
                <input
                    type="text"
                    class="search-input"
                    id="searchInput"
                    placeholder="Search for art..."
                    onkeypress="if(event.key === 'Enter') searchArt()">
            </div>

            <!-- Suggestions -->
            <div style="text-align: center; margin: 16px 0; font-size: 0.8rem; color: #666;">
                <span style="color: #999;">Try:</span>
                <button class="mode-link" onclick="suggestSearch('Monet')">Monet</button>
                <span style="color: #e5e5e5;">Â·</span>
                <button class="mode-link" onclick="suggestSearch('Japanese art')">Japanese art</button>
                <span style="color: #e5e5e5;">Â·</span>
                <button class="mode-link" onclick="suggestSearch('Bold colors')">Bold colors</button>
            </div>

            <div class="art-grid" id="artGrid"></div>

            <!-- Show more button -->
            <div class="show-more" id="browseShowMore" style="display: none;">
                <button class="show-more-btn" onclick="showMoreBrowse()">show 8 more</button>
            </div>
        </div>

        <!-- My Collection Mode -->
        <div class="browse-section" id="myCollectionMode">
            <div class="art-grid" id="collectionGrid"></div>

            <!-- Show more button -->
            <div class="show-more" id="collectionShowMore" style="display: none;">
                <button class="show-more-btn" onclick="showMoreCollection()">show 8 more</button>
            </div>
        </div>
    </div>

    <!-- Admin Link -->
    <a href="admin.html" class="admin-link">admin</a>

    <!-- Generation Progress Overlay -->
    <div class="generation-overlay" id="generationOverlay">
        <div class="generation-content">
            <div class="generation-spinner"></div>
            <div class="generation-status" id="generationStatusText">Generating image...</div>
            <div class="generation-prompt" id="generationPromptText"></div>
            <div class="generation-filename" id="generationFilenameText"></div>
        </div>
    </div>

    <!-- Art Preview Modal -->
    <div class="modal" id="artModal" onclick="if(event.target === this) closeModal()">
        <div class="modal-content">
            <button class="close-modal" onclick="closeModal()">Ã—</button>
            <button class="orientation-toggle" id="orientationToggle" onclick="togglePreviewOrientation()">âŸ²</button>

            <!-- Crop adjustment controls -->
            <div class="crop-controls">
                <button class="crop-btn crop-up" onclick="adjustCrop('up')">â†‘</button>
                <button class="crop-btn crop-down" onclick="adjustCrop('down')">â†“</button>
                <button class="crop-btn crop-left" onclick="adjustCrop('left')">â†</button>
                <button class="crop-btn crop-right" onclick="adjustCrop('right')">â†’</button>
                <button class="crop-btn crop-reset" onclick="adjustCrop('reset')">â—Ž</button>
            </div>

            <!-- Zoom controls -->
            <div class="zoom-controls">
                <button class="zoom-btn zoom-in" onclick="adjustZoom('in')">+</button>
                <button class="zoom-btn zoom-out" onclick="adjustZoom('out')">âˆ’</button>
                <button class="zoom-btn zoom-fit" onclick="adjustZoom('fit')">âŠ¡</button>
            </div>

            <img id="modalImage" class="modal-image" src="" alt="">
            <div class="modal-info">
                <div class="modal-actions">
                    <button class="btn btn-primary" onclick="applyModalArt()">Apply to Display</button>
                </div>
                <div style="text-align: center; margin-top: 12px;">
                    <button class="mode-link" id="modalSecondaryAction" onclick="handleSecondaryAction()" style="display: none;"></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" onchange="handleFileSelect(event)">

    <script>
        // Global state
        let currentMode = 'create';
        let currentArtResults = [];
        let selectedModalArt = null;
        let selectedHistoryItem = null;
        let defaultOrientation = 'portrait';
        let secondaryActionType = null; // 'add', 'remove', 'delete'

        // Browse state
        let browseDisplayCount = getInitialDisplayCount();
        let collectionDisplayCount = getInitialDisplayCount();
        let allArtworks = [];
        let myCollection = [];
        let filteredCollection = [];
        let currentFilter = 'all';
        let collectionSearchQuery = '';
        let collectionSortBy = 'date-desc';

        // Determine initial display count based on screen size
        function getInitialDisplayCount() {
            const width = window.innerWidth;
            if (width >= 768) return 16; // Desktop: 4 rows of 4 columns
            if (width >= 601) return 12; // Tablet: 4 rows of 3 columns
            return 8; // Mobile: 8 items in single column
        }

        // Determine increment for "show more" based on screen size
        function getShowMoreIncrement() {
            const width = window.innerWidth;
            if (width >= 768) return 12; // Desktop: 3 more rows
            if (width >= 601) return 9; // Tablet: 3 more rows
            return 8; // Mobile: 8 more items
        }

        // Load settings
        async function loadSettings() {
            try {
                const response = await fetch('/api/settings');
                const settings = await response.json();
                defaultOrientation = settings.defaultOrientation || 'portrait';
            } catch (error) {
                console.error('Failed to load settings:', error);
                defaultOrientation = 'portrait';
            }
        }

        // Apply default orientation to modal image
        function applyDefaultOrientation() {
            const modalImage = document.getElementById('modalImage');
            if (defaultOrientation === 'landscape') {
                modalImage.classList.add('landscape');
            } else {
                modalImage.classList.remove('landscape');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            loadCurrentDisplay();
            loadAllArt();
            loadMyCollection();
            setupDragDrop();
            setInterval(loadCurrentDisplay, 30000);
        });

        // Mode switching
        function switchMode(mode) {
            currentMode = mode;

            // Hide all modes
            document.getElementById('createMode').style.display = 'none';
            document.getElementById('exploreMode').classList.remove('show');
            document.getElementById('myCollectionMode').classList.remove('show');

            // Show selected mode
            if (mode === 'create') {
                document.getElementById('createMode').style.display = 'block';
            } else if (mode === 'explore') {
                document.getElementById('exploreMode').classList.add('show');
                browseDisplayCount = 8;
                if (currentArtResults.length === 0) {
                    loadAllArt(); // Load initial art
                } else {
                    displayArtResults();
                }
            } else if (mode === 'my-collection') {
                document.getElementById('myCollectionMode').classList.add('show');
                collectionDisplayCount = 8;
                displayMyCollection();
            }

            // Update tab colors
            document.getElementById('createLink').style.color = mode === 'create' ? '#1a1a1a' : '#999';
            document.getElementById('exploreLink').style.color = mode === 'explore' ? '#1a1a1a' : '#999';
            document.getElementById('myCollectionLink').style.color = mode === 'my-collection' ? '#1a1a1a' : '#999';
        }

        // Suggestion click
        function suggestSearch(query) {
            document.getElementById('searchInput').value = query;
            searchArt();
        }

        // Load current display
        async function loadCurrentDisplay() {
            try {
                const response = await fetch('/api/current-full.json');
                const data = await response.json();

                if (data.imageId && data.originalImage) {
                    const preview = document.getElementById('currentImagePreview');
                    const img = document.getElementById('currentImageThumb');
                    const prompt = document.getElementById('currentImagePrompt');

                    img.src = `data:${data.originalImageMime || 'image/png'};base64,${data.originalImage}`;
                    preview.classList.add('show');

                    if (data.originalPrompt) {
                        prompt.textContent = `"${data.originalPrompt}"`;
                        prompt.classList.add('show');
                    } else {
                        prompt.classList.remove('show');
                    }
                }
            } catch (error) {
                console.error('Failed to load:', error);
            }
        }

        // Generate art
        async function generateArt() {
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) return;

            const overlay = document.getElementById('generationOverlay');
            const promptText = document.getElementById('generationPromptText');
            promptText.textContent = `"${prompt}"`;
            overlay.classList.add('show');

            try {
                const rotation = defaultOrientation === 'landscape' ? 90 : 0;

                const response = await fetch('/api/generate-art', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, rotation })
                });

                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('promptInput').value = '';
                    await loadCurrentDisplay();
                    overlay.classList.remove('show');

                    const imageId = (data.current && data.current.imageId) || data.imageId;
                    await openGeneratedImagePreview(imageId);

                    setTimeout(loadMyCollection, 1000);
                } else {
                    overlay.classList.remove('show');
                    const errorData = await response.json();
                    alert('Generation failed: ' + (errorData.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Generation failed:', error);
                overlay.classList.remove('show');
                alert('Generation failed: ' + error.message);
            }
        }

        // Open preview modal for newly generated image
        async function openGeneratedImagePreview(imageId) {
            try {
                const response = await fetch(`/api/images/${imageId}`);
                if (!response.ok) {
                    console.error('Generated image not found');
                    return;
                }

                const item = await response.json();
                selectedHistoryItem = item;

                const imageSrc = item.originalImage
                    ? `data:${item.originalImageMime || 'image/png'};base64,${item.originalImage}`
                    : `data:image/png;base64,${item.thumbnail}`;

                document.getElementById('modalImage').src = imageSrc;
                applyDefaultOrientation();
                document.getElementById('deleteModalBtn').style.display = 'inline-block';
                document.getElementById('artModal').classList.add('show');
            } catch (error) {
                console.error('Failed to open preview:', error);
            }
        }

        // Feeling lucky
        async function feelingLucky() {
            try {
                const currentPrompt = document.getElementById('promptInput').value.trim();
                const response = await fetch('/api/lucky-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentPrompt })
                });
                const data = await response.json();
                if (data.prompt) {
                    document.getElementById('promptInput').value = data.prompt;
                }
            } catch (error) {
                console.error('Lucky prompt failed:', error);
            }
        }

        // Search art
        async function searchArt() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            const grid = document.getElementById('artGrid');
            grid.innerHTML = '<div class="loading">Searching...</div>';

            try {
                const response = await fetch(`/api/art/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                currentArtResults = data.results || [];
                browseDisplayCount = 8;
                displayArtResults();
            } catch (error) {
                grid.innerHTML = '<div class="loading">Search failed</div>';
            }
        }

        async function loadAllArt() {
            try {
                const response = await fetch('/api/collections');
                const data = await response.json();

                allArtworks = [];
                for (const collection of data.collections) {
                    const collResponse = await fetch(`/api/collections/${collection.id}`);
                    const collData = await collResponse.json();
                    collData.artworks.forEach(artwork => {
                        artwork.collectionId = collection.id;
                        allArtworks.push(artwork);
                    });
                }

                filterArt('all');
            } catch (error) {
                console.error('Failed to load art:', error);
            }
        }

        async function loadMyCollection() {
            try {
                const response = await fetch('/api/my-collection');
                myCollection = await response.json();

                if (currentBrowseView === 'my-collection') {
                    displayMyCollection();
                }
            } catch (error) {
                console.error('Failed to load my collection:', error);
            }
        }

        function displayMyCollection() {
            const grid = document.getElementById('collectionGrid');
            const showMoreBtn = document.getElementById('collectionShowMore');

            if (myCollection.length === 0) {
                grid.innerHTML = '<div class="loading">Your collection is empty</div>';
                showMoreBtn.style.display = 'none';
                return;
            }

            const displayedItems = myCollection.slice(0, collectionDisplayCount);
            grid.innerHTML = displayedItems.map(item => {
                // Handle different item types
                const imageUrl = item.imageUrl || (item.thumbnail ? `data:image/png;base64,${item.thumbnail}` : '');
                const title = item.title || item.originalPrompt?.substring(0, 30) || 'Untitled';
                const artist = item.artist || (item.collectionType === 'generated' ? 'Generated' : 'Uploaded');

                return `
                    <div class="art-item" onclick='openCollectionItem(${JSON.stringify(item).replace(/'/g, "&apos;")})'>
                        <img class="art-image" src="${imageUrl}" alt="${title}">
                        <div class="art-title">${title} ${artist !== 'Generated' && artist !== 'Uploaded' ? `Â· ${artist}` : ''}</div>
                    </div>
                `;
            }).join('');

            // Show "show more" button if there are more results
            if (collectionDisplayCount < myCollection.length) {
                const increment = getShowMoreIncrement();
                document.getElementById('showMoreCollectionBtn').textContent = `show ${increment} more`;
                showMoreBtn.style.display = 'block';
            } else {
                showMoreBtn.style.display = 'none';
            }
        }

        function showMoreCollection() {
            collectionDisplayCount += getShowMoreIncrement();
            displayMyCollection();
        }

        function filterArt(collectionId) {
            currentFilter = collectionId;

            if (collectionId === 'all') {
                currentArtResults = allArtworks;
            } else {
                currentArtResults = allArtworks.filter(art => art.collectionId === collectionId);
            }

            browseDisplayCount = 8;
            displayArtResults();
        }

        function displayArtResults() {
            const grid = document.getElementById('artGrid');
            const showMoreBtn = document.getElementById('browseShowMore');

            if (currentArtResults.length === 0) {
                grid.innerHTML = '<div class="loading">No results</div>';
                showMoreBtn.style.display = 'none';
                return;
            }

            const displayedResults = currentArtResults.slice(0, browseDisplayCount);
            grid.innerHTML = displayedResults.map(art => `
                <div class="art-item" onclick='previewArt(${JSON.stringify(art).replace(/'/g, "&apos;")})'>
                    <img class="art-image" src="${art.thumbnail || art.imageUrl}" alt="${art.title}">
                    <div class="art-title">${art.title}</div>
                </div>
            `).join('');

            // Show "show more" button if there are more results
            if (browseDisplayCount < currentArtResults.length) {
                const increment = getShowMoreIncrement();
                document.getElementById('showMoreBrowseBtn').textContent = `show ${increment} more`;
                showMoreBtn.style.display = 'block';
            } else {
                showMoreBtn.style.display = 'none';
            }
        }

        function showMoreBrowse() {
            browseDisplayCount += getShowMoreIncrement();
            displayArtResults();
        }

        function previewArt(art) {
            selectedModalArt = art;
            selectedHistoryItem = null;
            document.getElementById('modalImage').src = art.imageUrl;
            applyDefaultOrientation();

            // Show "add to collection" link
            const secondaryAction = document.getElementById('modalSecondaryAction');
            secondaryAction.textContent = 'add to collection';
            secondaryAction.style.display = 'block';
            secondaryActionType = 'add';

            document.getElementById('artModal').classList.add('show');
        }

        async function openCollectionItem(item) {
            try {
                selectedHistoryItem = item;
                selectedModalArt = null;

                // Determine image source
                let imageSrc;
                if (item.imageUrl) {
                    imageSrc = item.imageUrl;
                } else if (item.originalImage) {
                    imageSrc = `data:${item.originalImageMime || 'image/png'};base64,${item.originalImage}`;
                } else if (item.thumbnail) {
                    imageSrc = `data:image/png;base64,${item.thumbnail}`;
                }

                document.getElementById('modalImage').src = imageSrc;
                applyDefaultOrientation();

                // Set appropriate secondary action
                const secondaryAction = document.getElementById('modalSecondaryAction');
                if (item.collectionType === 'generated' || item.collectionType === 'uploaded') {
                    secondaryAction.textContent = 'delete';
                    secondaryAction.style.display = 'block';
                    secondaryActionType = 'delete';
                } else if (item.collectionType === 'added') {
                    secondaryAction.textContent = 'remove from collection';
                    secondaryAction.style.display = 'block';
                    secondaryActionType = 'remove';
                } else {
                    secondaryAction.style.display = 'none';
                    secondaryActionType = null;
                }

                document.getElementById('artModal').classList.add('show');
            } catch (error) {
                console.error('Failed to open collection item:', error);
            }
        }

        function closeModal() {
            document.getElementById('artModal').classList.remove('show');
            selectedModalArt = null;
            selectedHistoryItem = null;
            secondaryActionType = null;
            document.getElementById('modalSecondaryAction').style.display = 'none';

            const modalImage = document.getElementById('modalImage');
            modalImage.classList.remove('landscape');
            cropX = 50;
            cropY = 50;
            modalImage.style.objectPosition = '50% 50%';
            zoomLevel = 1.0;
            modalImage.style.transform = 'scale(1)';
            modalImage.style.objectFit = 'cover';
        }

        async function handleSecondaryAction() {
            if (secondaryActionType === 'add') {
                await addToCollection();
            } else if (secondaryActionType === 'delete') {
                await deleteModalImage();
            } else if (secondaryActionType === 'remove') {
                await removeFromCollection();
            }
        }

        async function addToCollection() {
            if (!selectedModalArt) return;

            try {
                const response = await fetch('/api/my-collection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageUrl: selectedModalArt.imageUrl,
                        title: selectedModalArt.title,
                        artist: selectedModalArt.artist,
                        year: selectedModalArt.year,
                        thumbnail: selectedModalArt.thumbnail,
                        collectionId: selectedModalArt.collectionId,
                        wikimedia: selectedModalArt.wikimedia
                    })
                });

                if (response.ok) {
                    // Hide the action after adding
                    document.getElementById('modalSecondaryAction').style.display = 'none';
                    secondaryActionType = null;

                    // Reload collection
                    await loadMyCollection();

                    console.log('Added to collection');
                } else {
                    const data = await response.json();
                    if (data.error === 'Artwork already in collection') {
                        document.getElementById('modalSecondaryAction').style.display = 'none';
                        secondaryActionType = null;
                    } else {
                        alert('Failed to add to collection: ' + data.error);
                    }
                }
            } catch (error) {
                console.error('Add to collection failed:', error);
                alert('Failed to add to collection');
            }
        }

        async function removeFromCollection() {
            if (!selectedHistoryItem || !selectedHistoryItem.id) return;

            if (!confirm('Remove this artwork from your collection?')) {
                return;
            }

            try {
                const response = await fetch(`/api/my-collection/${selectedHistoryItem.id}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    closeModal();
                    await loadMyCollection();
                } else {
                    const data = await response.json();
                    alert('Failed to remove: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Remove failed:', error);
                alert('Failed to remove from collection');
            }
        }

        function togglePreviewOrientation() {
            const modalImage = document.getElementById('modalImage');
            modalImage.classList.toggle('landscape');
        }

        // Crop adjustment
        let cropX = 50;
        let cropY = 50;
        const CROP_STEP = 5;

        function adjustCrop(direction) {
            const modalImage = document.getElementById('modalImage');

            switch(direction) {
                case 'up':
                    cropY = Math.max(0, cropY - CROP_STEP);
                    break;
                case 'down':
                    cropY = Math.min(100, cropY + CROP_STEP);
                    break;
                case 'left':
                    cropX = Math.max(0, cropX - CROP_STEP);
                    break;
                case 'right':
                    cropX = Math.min(100, cropX + CROP_STEP);
                    break;
                case 'reset':
                    cropX = 50;
                    cropY = 50;
                    break;
            }

            modalImage.style.objectPosition = `${cropX}% ${cropY}%`;
        }

        // Zoom adjustment
        let zoomLevel = 1.0;
        const ZOOM_STEP = 0.1;

        function adjustZoom(direction) {
            const modalImage = document.getElementById('modalImage');

            switch(direction) {
                case 'in':
                    zoomLevel = Math.min(2.0, zoomLevel + ZOOM_STEP);
                    break;
                case 'out':
                    zoomLevel = Math.max(0.5, zoomLevel - ZOOM_STEP);
                    break;
                case 'fit':
                    zoomLevel = 1.0;
                    break;
            }

            modalImage.style.transform = `scale(${zoomLevel})`;

            if (zoomLevel < 1.0) {
                modalImage.style.objectFit = 'contain';
            } else {
                modalImage.style.objectFit = 'cover';
            }
        }

        // File upload
        function setupDragDrop() {
            const zone = document.getElementById('dropZone');

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');

                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    handleFileUpload(files[0]);
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFileUpload(file);
            }
        }

        async function handleFileUpload(file) {
            const overlay = document.getElementById('generationOverlay');
            const statusText = document.getElementById('generationStatusText');
            const promptText = document.getElementById('generationPromptText');
            const filenameText = document.getElementById('generationFilenameText');

            statusText.textContent = 'Uploading image...';
            promptText.textContent = '';
            filenameText.textContent = file.name;
            overlay.classList.add('show');

            const formData = new FormData();
            formData.append('image', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('fileInput').value = '';
                    await loadCurrentDisplay();
                    overlay.classList.remove('show');
                    statusText.textContent = 'Generating image...';
                    filenameText.textContent = '';

                    await openGeneratedImagePreview(data.imageId || 'current');
                    setTimeout(loadMyCollection, 1000);
                } else {
                    overlay.classList.remove('show');
                    statusText.textContent = 'Generating image...';
                    filenameText.textContent = '';
                    const errorData = await response.json();
                    alert('Upload failed: ' + (errorData.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Upload failed:', error);
                overlay.classList.remove('show');
                statusText.textContent = 'Generating image...';
                filenameText.textContent = '';
                alert('Upload failed: ' + error.message);
            }
        }

        // History (kept for generated/uploaded images)
        async function openHistoryPreview(imageId) {
            try {
                const response = await fetch(`/api/images/${imageId}`);
                if (!response.ok) {
                    console.error('Image not found');
                    return;
                }

                const item = await response.json();
                selectedHistoryItem = item;

                const imageSrc = item.originalImage
                    ? `data:${item.originalImageMime || 'image/png'};base64,${item.originalImage}`
                    : `data:image/png;base64,${item.thumbnail}`;

                document.getElementById('modalImage').src = imageSrc;
                applyDefaultOrientation();
                document.getElementById('deleteModalBtn').style.display = 'inline-block';
                document.getElementById('artModal').classList.add('show');
            } catch (error) {
                console.error('Failed to open preview:', error);
            }
        }

        async function applyModalArt() {
            if (!selectedModalArt && !selectedHistoryItem) return;

            try {
                let response;
                const modalImage = document.getElementById('modalImage');
                const isLandscape = modalImage.classList.contains('landscape');
                const rotation = isLandscape ? 90 : 0;

                if (selectedHistoryItem) {
                    response = await fetch(`/api/history/${selectedHistoryItem.imageId}/load`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ rotation })
                    });
                } else if (selectedModalArt) {
                    response = await fetch('/api/art/import', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            imageUrl: selectedModalArt.imageUrl,
                            title: selectedModalArt.title,
                            artist: selectedModalArt.artist,
                            rotation: rotation
                        })
                    });
                }

                if (response && response.ok) {
                    closeModal();
                    setTimeout(loadCurrentDisplay, 2000);
                }
            } catch (error) {
                console.error('Apply art failed:', error);
            }
        }

        async function deleteModalImage() {
            if (!selectedHistoryItem) return;

            if (!confirm('Are you sure you want to delete this image?')) {
                return;
            }

            try {
                const response = await fetch(`/api/history/${selectedHistoryItem.imageId}`, { method: 'DELETE' });
                if (response.ok) {
                    closeModal();
                    await loadMyCollection();
                } else {
                    const data = await response.json();
                    alert('Failed to delete: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Delete failed:', error);
                alert('Failed to delete image');
            }
        }
    </script>
</body>
</html>
